{"version":3,"sources":["index.js","define.js","global.js","cache.js","emitter.js","utils.js","parent.js","children.js","store.js","router.js","template/index.js","template/core.js","template/utils.js","template/resolvers/value.js","template/resolvers/array.js","template/resolvers/node.js","template/resolvers/property.js","template/resolvers/event.js","template/resolvers/class.js","template/resolvers/style.js","template/helpers.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;AGRA,AFMA,ACHA,AFMA;AGRA,AFMA,ACHA,AFMA;AGRA,AFMA,ACHA,AFMA;AGRA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,AFMA,AGTA;AFOA,AFMA,AGTA,AFMA,AGTA;AFOA,AFMA,AGTA,AFMA,AGTA;AFOA,AFMA,AGTA,AFMA,AIZA,ADGA;AFOA,AFMA,AGTA,AFMA,AIZA,ADGA;AFOA,AFMA,AGTA,AFMA,AIZA,ADGA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,ADGA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,ADGA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,ADGA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,AENA,AHSA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,AENA,AHSA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,AENA,AHSA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,AGTA,ADGA,AHSA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,AGTA,ADGA,AHSA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,AGTA,ADGA,AHSA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,AGTA,ADGA,AENA,ALeA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,AGTA,ADGA,AENA,ALeA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,AGTA,ADGA,AENA,ALeA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,AGTA,ADGA,AGTA,ADGA,ALeA;AFOA,AIZA,ANkBA,AGTA,AFMA,AIZA,AGTA,ADGA,AGTA,ADGA,ALeA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,ALeA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AENA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AENA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AENA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AGTA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AGTA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AGTA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AIZA,ADGA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AIZA,ADGA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AIZA,ADGA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AIZA,ACHA,AFMA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AIZA,ACHA,AFMA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AIZA,ACHA,AFMA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AIZA,ACHA,ACHA,AHSA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AIZA,ACHA,ACHA,AHSA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AIZA,ACHA,ACHA,AHSA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AIZA,AGTA,AFMA,ACHA,AHSA,ADGA,APqBA;AFOA,AIZA,ANkBA,AGTA,AENA,AGTA,ADGA,AGTA,ADGA,AIZA,AGTA,AFMA,ACHA,AHSA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,ADGA,AIZA,AGTA,AFMA,ACHA,AHSA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,ADGA,AIZA,AIZA,ADGA,AFMA,ACHA,AHSA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,ADGA,AIZA,AIZA,ADGA,AFMA,ACHA,AHSA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,ADGA,AIZA,AIZA,ADGA,AFMA,ACHA,AHSA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,ADGA,AIZA,AIZA,ADGA,AFMA,ACHA,AGTA,ANkBA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,ADGA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,ADGA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AIZA,ANkBA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA,APqBA;AFOA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,ANkBA,ADGA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,APqBA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,APqBA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,APqBA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AIZA,ADGA,ADGA,AGTA,APqBA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AGTA,ADGA,AGTA,APqBA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AGTA,AENA,APqBA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AGTA,AENA,APqBA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AGTA,AENA,APqBA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AGTA,AENA,APqBA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AKfA,APqBA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AKfA,APqBA;AT4BA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AKfA;AhBiDA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AKfA;AhBiDA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA,AKfA;AhBiDA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,AV8BA,AIZA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA,ANkBA;AXkCA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA,AS3BA;AjBoDA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;ARyBA,AFMA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AV+BA,AQxBA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./define.js');Object.defineProperty(exports, 'define', { enumerable: true, configurable: true, get: function() { return __TEMP__.default; } });\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./parent.js');Object.defineProperty(exports, 'parent', { enumerable: true, configurable: true, get: function() { return __TEMP__.default; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./children.js');Object.defineProperty(exports, 'children', { enumerable: true, configurable: true, get: function() { return __TEMP__.default; } });\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./store.js');Object.defineProperty(exports, 'store', { enumerable: true, configurable: true, get: function() { return __TEMP__.default; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./router.js');Object.defineProperty(exports, 'router', { enumerable: true, configurable: true, get: function() { return __TEMP__.default; } });\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./template/index.js');Object.defineProperty(exports, 'html', { enumerable: true, configurable: true, get: function() { return __TEMP__.html; } });Object.defineProperty(exports, 'svg', { enumerable: true, configurable: true, get: function() { return __TEMP__.svg; } });\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./utils.js');Object.defineProperty(exports, 'dispatch', { enumerable: true, configurable: true, get: function() { return __TEMP__.dispatch; } });\n","var __TEMP__ = require('./global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./cache.js');var cache = __REQUIRE_WILDCARD__(__TEMP__);\nvar __TEMP__ = require('./utils.js');var deferred = __TEMP__['deferred'];var camelToDash = __TEMP__['camelToDash'];var walkInShadow = __TEMP__['walkInShadow'];\n\nconst propsMap = new WeakMap();\nconst disconnects = new WeakMap();\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var callbacksMap = exports.callbacksMap = new WeakMap();\n\nclass HybridsRootElement extends global.HTMLElement {\n  constructor() {\n    super();\n\n    const props = propsMap.get(this.constructor);\n\n    for (let index = 0; index < props.length; index += 1) {\n      const key = props[index];\n      if (hasOwnProperty.call(this, key)) {\n        const value = this[key];\n        delete this[key];\n        this[key] = value;\n      }\n    }\n\n    cache.suspend(this);\n  }\n\n  connectedCallback() {\n    cache.unsuspend(this);\n\n    const callbacks = callbacksMap.get(this.constructor);\n    const list = [];\n\n    for (let index = 0; index < callbacks.length; index += 1) {\n      const cb = callbacks[index](this);\n      if (cb) list.push(cb);\n    }\n\n    disconnects.set(this, list);\n  }\n\n  disconnectedCallback() {\n    cache.suspend(this);\n\n    const list = disconnects.get(this);\n    for (let index = 0; index < list.length; index += 1) {\n      list[index]();\n    }\n  }\n}\n\nfunction render(fn, useShadow) {\n  return {\n    get: useShadow\n      ? (host) => {\n          const updateDOM = fn(host);\n          const target =\n            host.shadowRoot ||\n            host.attachShadow({\n              mode: \"open\",\n              delegatesFocus: fn.delegatesFocus || false,\n            });\n          return () => {\n            updateDOM(host, target);\n            return target;\n          };\n        }\n      : (host) => {\n          const updateDOM = fn(host);\n          return () => {\n            updateDOM(host, host);\n            return host;\n          };\n        },\n    observe(host, flush) { flush(); }, // prettier-ignore\n  };\n}\n\nconst transforms = {\n  string: String,\n  number: Number,\n  boolean: Boolean,\n  undefined: (v) => v,\n};\n\nfunction property(key, desc) {\n  const type = typeof desc.value;\n  const transform = transforms[type];\n\n  if (!transform) {\n    throw TypeError(\n      `Invalid default value for '${key}' property - it must be a string, number, boolean or undefined: ${type}`,\n    );\n  }\n\n  const defaultValue = desc.value;\n  const attrName = camelToDash(key);\n\n  const setAttr = (host, value) => {\n    if (\n      (!value && value !== 0) ||\n      (typeof value === \"object\" && value.toString() === undefined)\n    ) {\n      host.removeAttribute(attrName);\n    } else {\n      host.setAttribute(attrName, type === \"boolean\" ? \"\" : value);\n    }\n    return value;\n  };\n\n  return {\n    get: (host, value) => {\n      if (value === undefined) {\n        if (host.hasAttribute(attrName)) {\n          value = transform(type === \"boolean\" || host.getAttribute(attrName));\n        } else {\n          return defaultValue;\n        }\n      }\n      return value;\n    },\n    set:\n      type !== \"undefined\"\n        ? (host, value) => setAttr(host, transform(value))\n        : (host, value) => value,\n    connect:\n      type !== \"undefined\"\n        ? (host, _, invalidate) => {\n            if (!host.hasAttribute(attrName) && host[key] === defaultValue) {\n              setAttr(host, defaultValue);\n            }\n\n            return desc.connect && desc.connect(host, _, invalidate);\n          }\n        : desc.connect,\n    observe: desc.observe,\n  };\n}\n\nfunction compile(hybrids, HybridsElement) {\n  if (HybridsElement) {\n    if (hybrids === HybridsElement.hybrids) return HybridsElement;\n    propsMap.get(HybridsElement).forEach((key) => {\n      delete HybridsElement.prototype[key];\n    });\n  } else {\n    HybridsElement = class extends HybridsRootElement {};\n  }\n\n  HybridsElement.hybrids = hybrids;\n\n  const callbacks = [];\n  const props = Object.keys(hybrids);\n\n  callbacksMap.set(HybridsElement, callbacks);\n  propsMap.set(HybridsElement, props);\n\n  props.forEach((key) => {\n    if (key === \"tag\") return;\n\n    let desc = hybrids[key];\n    const type = typeof desc;\n\n    if (type === \"function\") {\n      if (key === \"render\") {\n        desc = render(desc, true);\n      } else if (key === \"content\") {\n        desc = render(desc);\n      } else {\n        desc = { get: desc };\n      }\n    } else if (type !== \"object\" || desc === null) {\n      desc = { value: desc };\n    } else if (desc.set) {\n      const attrName = camelToDash(key);\n      const get = desc.get || ((host, value) => value);\n      desc.get = (host, value) => {\n        if (value === undefined) {\n          value = desc.set(host, host.getAttribute(attrName) || value);\n        }\n        return get(host, value);\n      };\n    }\n\n    if (hasOwnProperty.call(desc, \"value\")) {\n      desc = property(key, desc);\n    } else if (!desc.get) {\n      throw TypeError(\n        `Invalid descriptor for '${key}' property - it must contain 'value' or 'get' option`,\n      );\n    }\n\n    Object.defineProperty(HybridsElement.prototype, key, {\n      get: function get() {\n        return cache.get(this, key, desc.get);\n      },\n      set:\n        desc.set &&\n        function set(newValue) {\n          cache.set(this, key, desc.set, newValue);\n        },\n      enumerable: true,\n      configurable: true,\n    });\n\n    if (desc.observe) {\n      callbacks.unshift((host) =>\n        cache.observe(host, key, desc.get, desc.observe),\n      );\n    }\n\n    if (desc.connect) {\n      callbacks.push((host) => {\n        function invalidate(options) {\n          cache.invalidate(host, key, {\n            force: typeof options === \"object\" && options.force === true,\n          });\n        }\n        return desc.connect(host, key, invalidate);\n      });\n    }\n  });\n\n  return HybridsElement;\n}\n\nconst updateQueue = new Map();\nfunction update(HybridsElement) {\n  if (!updateQueue.size) {\n    deferred.then(() => {\n      walkInShadow(global.document.body, (node) => {\n        if (updateQueue.has(node.constructor)) {\n          const prevHybrids = updateQueue.get(node.constructor);\n          const hybrids = node.constructor.hybrids;\n          node.disconnectedCallback();\n\n          Object.keys(hybrids).forEach((key) => {\n            const type = typeof hybrids[key];\n            const clearValue =\n              type !== \"object\" &&\n              type !== \"function\" &&\n              hybrids[key] !== prevHybrids[key];\n            cache.invalidate(node, key, { clearValue });\n          });\n\n          node.connectedCallback();\n        }\n      });\n      updateQueue.clear();\n    });\n  }\n  updateQueue.set(HybridsElement, HybridsElement.hybrids);\n}\n\nfunction define(hybrids) {\n  if (!hybrids.tag) {\n    throw TypeError(\n      \"Error while defining hybrids: 'tag' property with dashed tag name is required\",\n    );\n  }\n\n  const HybridsElement = global.customElements.get(hybrids.tag);\n\n  if (HybridsElement) {\n    if (HybridsElement.hybrids) {\n      update(HybridsElement);\n      compile(hybrids, HybridsElement);\n\n      return Object.freeze(hybrids);\n    }\n\n    throw TypeError(\n      `Custom element with '${hybrids.tag}' tag name already defined outside of the hybrids context`,\n    );\n  }\n\n  global.customElements.define(hybrids.tag, compile(hybrids));\n  return Object.freeze(hybrids);\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = Object.freeze(\n  Object.assign(define, { compile: (hybrids) => compile(hybrids) }),\n);\n","if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function polyfill(global) {\n  global = Object.create(global);\n\n  if (!(\"requestAnimationFrame\" in global)) {\n    Object.defineProperty(global, \"requestAnimationFrame\", {\n      value: function requestAnimationFrame(callback) {\n        return setTimeout(callback, 0);\n      },\n    });\n  }\n\n  if (!(\"HTMLElement\" in global)) {\n    Object.defineProperty(global, \"HTMLElement\", {\n      value: class HTMLElement {\n        constructor() {\n          throw Error(\n            \"Current context does not support defining custom elements\",\n          );\n        }\n      },\n    });\n  }\n\n  return global;\n};exports.polyfill = polyfill\n\n/* istanbul ignore else */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = typeof window === \"object\" ? window : polyfill(globalThis);\n","var __TEMP__ = require('./global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./emitter.js');var emitter = __REQUIRE_WILDCARD__(__TEMP__);\n\nconst entries = new WeakMap();\nconst suspense = new WeakSet();\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getEntry(target, key) {\n  let targetMap = entries.get(target);\n  if (!targetMap) {\n    targetMap = new Map();\n    entries.set(target, targetMap);\n  }\n\n  let entry = targetMap.get(key);\n\n  if (!entry) {\n    entry = {\n      target,\n      key,\n      value: undefined,\n      lastValue: undefined,\n      contexts: new Set(),\n      deps: new Set(),\n      state: 0,\n      depState: 0,\n      resolved: false,\n    };\n    targetMap.set(key, entry);\n  }\n\n  return entry;\n};exports.getEntry = getEntry\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getEntries(target) {\n  const result = [];\n  const targetMap = entries.get(target);\n  if (targetMap) {\n    targetMap.forEach((entry) => {\n      result.push(entry);\n    });\n  }\n  return result;\n};exports.getEntries = getEntries\n\nfunction cleanContexts(entry) {\n  entry.contexts.forEach((contextEntry) => {\n    if (suspense.has(contextEntry.target)) {\n      Object.assign(contextEntry, {\n        depState: 0,\n        resolved: false,\n      });\n\n      entry.contexts.delete(contextEntry);\n\n      cleanContexts(contextEntry);\n    }\n  });\n}\n\nfunction dispatchDeep(entry) {\n  entry.resolved = false;\n\n  if (!suspense.has(entry.target)) {\n    emitter.dispatch(entry);\n  }\n\n  cleanContexts(entry);\n  entry.contexts.forEach(dispatchDeep);\n}\n\nlet context = null;\nconst contexts = new Set();\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function get(target, key, getter) {\n  const entry = getEntry(target, key);\n\n  if (context && !suspense.has(context.target)) {\n    context.deps.add(entry);\n    entry.contexts.add(context);\n  }\n\n  if (!suspense.has(target)) {\n    cleanContexts(entry);\n\n    if (entry.resolved) {\n      return entry.value;\n    }\n\n    if (entry.depState > entry.state) {\n      let depState = entry.state;\n\n      for (const depEntry of entry.deps) {\n        // eslint-disable-next-line no-unused-expressions\n        depEntry.target[depEntry.key];\n\n        if (!depEntry.resolved) {\n          depState = false;\n          break;\n        }\n\n        depState += depEntry.state;\n      }\n\n      if (depState && depState === entry.depState) {\n        entry.resolved = true;\n        return entry.value;\n      }\n    }\n  }\n\n  const lastContext = context;\n\n  try {\n    if (contexts.has(entry)) {\n      throw Error(`Circular get invocation is forbidden: '${key}'`);\n    }\n\n    entry.deps.forEach((depEntry) => {\n      depEntry.contexts.delete(entry);\n    });\n\n    entry.deps.clear();\n    context = entry;\n    contexts.add(entry);\n\n    const nextValue = getter(target, entry.value);\n\n    context = lastContext;\n\n    if (nextValue !== entry.value) {\n      entry.value = nextValue;\n      entry.state += 1;\n    }\n\n    let depState = entry.state;\n    entry.deps.forEach((depEntry) => {\n      depState += depEntry.state;\n    });\n\n    entry.depState = depState;\n    entry.resolved = !suspense.has(target);\n\n    contexts.delete(entry);\n  } catch (e) {\n    context = lastContext;\n    contexts.delete(entry);\n\n    entry.resolved = false;\n\n    if (context && !suspense.has(context)) {\n      context.deps.delete(entry);\n      entry.contexts.delete(context);\n    }\n\n    throw e;\n  }\n\n  return entry.value;\n};exports.get = get\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function set(target, key, setter, value) {\n  const entry = getEntry(target, key);\n  const newValue = setter(target, value, entry.value);\n\n  if (newValue !== entry.value) {\n    entry.value = newValue;\n    entry.state += 1;\n    entry.depState = 0;\n\n    dispatchDeep(entry);\n  }\n};exports.set = set\n\nconst gcList = new Set();\nfunction deleteEntry(entry) {\n  if (!gcList.size) {\n    global.requestAnimationFrame(() => {\n      gcList.forEach((e) => {\n        if (e.contexts.size === 0) {\n          e.deps.forEach((depEntry) => {\n            depEntry.contexts.delete(e);\n          });\n\n          const targetMap = entries.get(e.target);\n          targetMap.delete(e.key);\n        }\n      });\n      gcList.clear();\n    });\n  }\n\n  gcList.add(entry);\n}\n\nfunction invalidateEntry(entry, options) {\n  entry.depState = 0;\n  dispatchDeep(entry);\n\n  if (options.clearValue) {\n    entry.value = undefined;\n    entry.lastValue = undefined;\n  }\n\n  if (options.deleteEntry) {\n    deleteEntry(entry);\n  }\n\n  if (options.force) {\n    entry.state += 1;\n  }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function invalidate(target, key, options = {}) {\n  if (contexts.size) {\n    throw Error(\n      `Invalidating property in chain of get calls is forbidden: '${key}'`,\n    );\n  }\n\n  const entry = getEntry(target, key);\n  invalidateEntry(entry, options);\n};exports.invalidate = invalidate\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function invalidateAll(target, options = {}) {\n  if (contexts.size) {\n    throw Error(\n      \"Invalidating all properties in chain of get calls is forbidden\",\n    );\n  }\n\n  const targetMap = entries.get(target);\n  if (targetMap) {\n    targetMap.forEach((entry) => {\n      invalidateEntry(entry, options);\n    });\n  }\n};exports.invalidateAll = invalidateAll\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function observe(target, key, getter, fn) {\n  const entry = getEntry(target, key);\n\n  return emitter.subscribe(entry, () => {\n    const value = get(target, key, getter);\n\n    if (value !== entry.lastValue) {\n      fn(target, value, entry.lastValue);\n      entry.lastValue = value;\n    }\n  });\n};exports.observe = observe\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function suspend(target) {\n  suspense.add(target);\n};exports.suspend = suspend\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function unsuspend(target) {\n  suspense.delete(target);\n};exports.unsuspend = unsuspend\n","var __TEMP__ = require('./global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst callbacks = new WeakMap();\nconst queue = new Set();\n\nfunction execute() {\n  try {\n    queue.forEach((target) => {\n      try {\n        callbacks.get(target)();\n        queue.delete(target);\n      } catch (e) {\n        queue.delete(target);\n        throw e;\n      }\n    });\n  } catch (e) {\n    if (queue.size) execute();\n    throw e;\n  }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function dispatch(target) {\n  if (callbacks.has(target)) {\n    if (!queue.size) {\n      global.requestAnimationFrame(execute);\n    }\n    queue.add(target);\n  }\n};exports.dispatch = dispatch\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function subscribe(target, cb) {\n  callbacks.set(target, cb);\n  dispatch(target);\n\n  return function unsubscribe() {\n    queue.delete(target);\n    callbacks.delete(target);\n  };\n};exports.subscribe = subscribe\n","var __TEMP__ = require('./global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst camelToDashMap = new Map();\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function camelToDash(str) {\n  let result = camelToDashMap.get(str);\n  if (result === undefined) {\n    result = str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n    camelToDashMap.set(str, result);\n  }\n  return result;\n};exports.camelToDash = camelToDash\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function dispatch(host, eventType, options = {}) {\n  return host.dispatchEvent(\n    new global.CustomEvent(eventType, { bubbles: false, ...options }),\n  );\n};exports.dispatch = dispatch\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function shadyCSS(fn, fallback) {\n  const shady = global.ShadyCSS;\n\n  /* istanbul ignore next */\n  if (shady && !shady.nativeShadow) {\n    return fn(shady);\n  }\n\n  return fallback;\n};exports.shadyCSS = shadyCSS\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function stringifyElement(target) {\n  return `<${String(target.tagName).toLowerCase()}>`;\n};exports.stringifyElement = stringifyElement\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function walkInShadow(target, cb) {\n  if (target.nodeType === global.Node.ELEMENT_NODE) {\n    cb(target);\n\n    if (target.shadowRoot) {\n      walkInShadow(target.shadowRoot, cb);\n    }\n  }\n\n  const walker = global.document.createTreeWalker(\n    target,\n    global.NodeFilter.SHOW_ELEMENT,\n    null,\n    false,\n  );\n\n  while (walker.nextNode()) {\n    const el = walker.currentNode;\n    cb(el);\n    if (el.shadowRoot) {\n      walkInShadow(el.shadowRoot, cb);\n    }\n  }\n};exports.walkInShadow = walkInShadow\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var deferred = exports.deferred = Promise.resolve();\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var storePointer = exports.storePointer = new WeakMap();\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var probablyDevMode = exports.probablyDevMode = walkInShadow.name === \"walkInShadow\";\n","function walk(node, fn) {\n  let parentElement = node.parentElement || node.parentNode.host;\n\n  while (parentElement) {\n    const hybrids = parentElement.constructor.hybrids;\n\n    if (hybrids && fn(hybrids, node)) {\n      return parentElement;\n    }\n\n    parentElement =\n      parentElement.parentElement ||\n      (parentElement.parentNode && parentElement.parentNode.host);\n  }\n\n  return parentElement || null;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function parent(hybridsOrFn) {\n  const fn =\n    typeof hybridsOrFn === \"function\"\n      ? hybridsOrFn\n      : (hybrids) => hybrids === hybridsOrFn;\n  return {\n    get: (host) => walk(host, fn),\n    connect(host, key, invalidate) {\n      const target = host[key];\n      if (target) {\n        return invalidate;\n      }\n      return false;\n    },\n  };\n};exports.default = parent\n","var __TEMP__ = require('./global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\n\nfunction walk(node, fn, options, items = [], host = node) {\n  Array.from(node.children).forEach((child) => {\n    const hybrids = child.constructor.hybrids;\n    if (hybrids && fn(hybrids, host)) {\n      items.push(child);\n      if (options.deep && options.nested) {\n        walk(child, fn, options, items, host);\n      }\n    } else if (options.deep) {\n      walk(child, fn, options, items, host);\n    }\n  });\n\n  return items;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function children(\n  hybridsOrFn,\n  options = { deep: false, nested: false },\n) {\n  const fn =\n    typeof hybridsOrFn === \"function\"\n      ? hybridsOrFn\n      : (hybrids) => hybrids === hybridsOrFn;\n\n  return {\n    get: (host) => walk(host, fn, options),\n    connect(host, key, invalidate) {\n      const observer = new global.MutationObserver(invalidate);\n\n      observer.observe(host, {\n        childList: true,\n        subtree: !!options.deep,\n      });\n\n      return () => {\n        observer.disconnect();\n      };\n    },\n  };\n};exports.default = children\n","/* eslint-disable no-use-before-define */\nvar __TEMP__ = require('./global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./cache.js');var cache = __REQUIRE_WILDCARD__(__TEMP__);\nvar __TEMP__ = require('./utils.js');var storePointer = __TEMP__['storePointer'];\n\nconst connect = Symbol(\"store.connect\");\n\nconst definitions = new WeakMap();\nconst stales = new WeakMap();\nconst refs = new WeakSet();\n\nfunction resolve(config, model, lastModel) {\n  if (lastModel) {\n    definitions.set(lastModel, null);\n    stales.set(lastModel, model);\n  }\n\n  definitions.set(model, config);\n\n  if (config.storage.observe) {\n    const modelValue = model && config.isInstance(model) ? model : null;\n\n    const lastModelValue =\n      lastModel && config.isInstance(lastModel) ? lastModel : null;\n\n    if (modelValue !== lastModelValue) {\n      config.storage.observe(modelValue, lastModelValue);\n    }\n  }\n\n  return model;\n}\n\nfunction shallowEqual(target, compare) {\n  return Object.keys(target).every((key) => target[key] === compare[key]);\n}\n\nfunction resolveWithInvalidate(config, model, lastModel) {\n  resolve(config, model, lastModel);\n\n  if (\n    config.invalidate &&\n    (!lastModel ||\n      error(model) ||\n      !config.isInstance(lastModel) ||\n      !shallowEqual(model, lastModel))\n  ) {\n    config.invalidate();\n  }\n\n  return model;\n}\n\nfunction syncCache(config, id, model, invalidate = true) {\n  cache.set(config, id, invalidate ? resolveWithInvalidate : resolve, model);\n  return model;\n}\n\nlet currentTimestamp;\nfunction getCurrentTimestamp() {\n  if (!currentTimestamp) {\n    currentTimestamp = Date.now();\n    global.requestAnimationFrame(() => {\n      currentTimestamp = undefined;\n    });\n  }\n  return currentTimestamp;\n}\n\nconst timestamps = new WeakMap();\n\nfunction getTimestamp(model) {\n  let timestamp = timestamps.get(model);\n\n  if (!timestamp) {\n    timestamp = getCurrentTimestamp();\n    timestamps.set(model, timestamp);\n  }\n\n  return timestamp;\n}\n\nfunction setTimestamp(model) {\n  timestamps.set(model, getCurrentTimestamp());\n  return model;\n}\n\nfunction invalidateTimestamp(model) {\n  timestamps.set(model, 1);\n  return model;\n}\n\nfunction hashCode(str) {\n  return global.btoa(\n    Array.from(str).reduce(\n      // eslint-disable-next-line no-bitwise\n      (s, c) => (Math.imul(31, s) + c.charCodeAt(0)) | 0,\n      0,\n    ),\n  );\n}\n\nconst offlinePrefix = \"hybrids:store:cache\";\nconst offlineKeys = {};\n\nlet clearPromise;\nfunction setupOfflineKey(config, threshold) {\n  const key = `${offlinePrefix}:${hashCode(JSON.stringify(config.model))}`;\n\n  offlineKeys[key] = getCurrentTimestamp() + threshold;\n\n  if (!clearPromise) {\n    clearPromise = Promise.resolve().then(() => {\n      const previousKeys =\n        JSON.parse(global.localStorage.getItem(offlinePrefix)) || {};\n      const timestamp = getCurrentTimestamp();\n\n      Object.keys(previousKeys).forEach((k) => {\n        /* istanbul ignore next */\n        if (!offlineKeys[k] && previousKeys[k] < timestamp) {\n          global.localStorage.removeItem(k);\n          delete previousKeys[k];\n        }\n      });\n\n      global.localStorage.setItem(\n        offlinePrefix,\n        JSON.stringify({ ...previousKeys, ...offlineKeys }),\n      );\n      clearPromise = null;\n    });\n  }\n\n  return key;\n}\n\nconst JSON_LIKE_REGEX = /^\\{.+\\}$/;\nfunction setupStorage(config, options) {\n  if (typeof options === \"function\") options = { get: options };\n\n  const result = {\n    cache: true,\n    loose: false,\n    ...options,\n  };\n\n  if (result.observe) {\n    const fn = result.observe;\n    if (typeof fn !== \"function\") {\n      throw TypeError(\n        `Storage 'observe' property must be a function: ${typeof result.observe}`,\n      );\n    }\n    result.observe = (model, lastModel) => {\n      try {\n        let id = lastModel ? lastModel.id : model.id;\n        if (JSON_LIKE_REGEX.test(id)) {\n          try {\n            id = JSON.parse(id);\n            // istanbul ignore next\n          } catch (e) {} // eslint-disable-line no-empty\n        }\n\n        fn(id, model, lastModel);\n      } catch (e) {\n        console.error(e);\n      }\n    };\n  }\n\n  if (result.cache === false || result.cache === 0) {\n    result.validate = (cachedModel) =>\n      !cachedModel || getTimestamp(cachedModel) === getCurrentTimestamp();\n  } else if (typeof result.cache === \"number\") {\n    result.validate = (cachedModel) =>\n      !cachedModel ||\n      getTimestamp(cachedModel) + result.cache > getCurrentTimestamp();\n  } else {\n    if (result.cache !== true) {\n      throw TypeError(\n        `Storage 'cache' property must be a boolean or number: ${typeof result.cache}`,\n      );\n    }\n    result.validate = (cachedModel) => getTimestamp(cachedModel) !== 1;\n  }\n\n  if (!result.get) {\n    result.get = (id) => {\n      throw notFoundError(stringifyId(id));\n    };\n  }\n\n  if (result.offline) {\n    const isBool = result.offline === true;\n    const threshold = isBool\n      ? 1000 * 60 * 60 * 24 * 30 /* 30 days */\n      : result.offline;\n    const offlineKey = setupOfflineKey(config, threshold);\n\n    try {\n      const items = JSON.parse(global.localStorage.getItem(offlineKey)) || {};\n\n      let flush;\n\n      result.offline = Object.freeze({\n        key: offlineKey,\n        threshold,\n        get: isBool\n          ? (id) => {\n              if (hasOwnProperty.call(items, id)) {\n                return JSON.parse(items[id][1]);\n              }\n              return null;\n            }\n          : (id) => {\n              if (hasOwnProperty.call(items, id)) {\n                const item = items[id];\n                if (item[0] + threshold < getCurrentTimestamp()) {\n                  delete items[id];\n                  return null;\n                }\n                return JSON.parse(item[1]);\n              }\n              return null;\n            },\n        set(id, values) {\n          if (values) {\n            items[id] = [\n              getCurrentTimestamp(),\n              JSON.stringify(values, function replacer(key, value) {\n                if (value === this[\"\"]) return value;\n\n                if (value && typeof value === \"object\") {\n                  const valueConfig = definitions.get(value);\n                  if (valueConfig === config && value.id === id) {\n                    return String(value);\n                  }\n\n                  const offline = valueConfig && valueConfig.storage.offline;\n                  if (offline) {\n                    if (valueConfig.list) {\n                      return value.map((model) => {\n                        configs\n                          .get(valueConfig.model)\n                          .storage.offline.set(model.id, model);\n                        return `${model}`;\n                      });\n                    }\n\n                    valueConfig.storage.offline.set(value.id, value);\n                    return `${value}`;\n                  }\n                }\n\n                return value;\n              }),\n            ];\n          } else {\n            delete items[id];\n          }\n\n          if (!flush) {\n            flush = Promise.resolve().then(() => {\n              const timestamp = getCurrentTimestamp();\n\n              Object.keys(items).forEach((key) => {\n                if (items[key][0] + threshold < timestamp) {\n                  delete items[key];\n                }\n              });\n\n              global.localStorage.setItem(offlineKey, JSON.stringify(items));\n              flush = null;\n            });\n          }\n\n          return values;\n        },\n      });\n    } catch (e) /* istanbul ignore next */ {\n      console.error(e);\n      result.offline = false;\n    }\n  }\n\n  return Object.freeze(result);\n}\n\nfunction memoryStorage(config) {\n  return {\n    get: config.enumerable ? () => {} : () => config.create({}),\n    set: config.enumerable\n      ? (id, values) => values\n      : (id, values) => (values === null ? { id } : values),\n    list:\n      config.enumerable &&\n      function list(id) {\n        if (id) {\n          throw TypeError(`Memory-based model definition does not support id`);\n        }\n\n        return cache.getEntries(config).reduce((acc, { key, value }) => {\n          if (key === config) return acc;\n          if (value && !error(value)) acc.push(key);\n          return acc;\n        }, []);\n      },\n    loose: true,\n  };\n}\n\nfunction bootstrap(Model, nested) {\n  if (Array.isArray(Model)) {\n    return setupListModel(Model[0], nested);\n  }\n  return setupModel(Model, nested);\n}\n\nfunction getTypeConstructor(type, key) {\n  switch (type) {\n    case \"string\":\n      return (v) => (v !== undefined && v !== null ? String(v) : \"\");\n    case \"number\":\n      return Number;\n    case \"boolean\":\n      return Boolean;\n    default:\n      throw TypeError(\n        `The value of the '${key}' must be a string, number or boolean: ${type}`,\n      );\n  }\n}\n\nconst stateSetter = (_, value, lastValue) => {\n  if (value.state === \"error\") {\n    return { state: \"error\", error: value.value };\n  }\n\n  value.error = !!lastValue && lastValue.error;\n\n  return value;\n};\nfunction setModelState(model, state, value = model) {\n  cache.set(model, \"state\", stateSetter, { state, value });\n  return model;\n}\n\nconst stateGetter = (\n  model,\n  v = { state: \"ready\", value: model, error: false },\n) => v;\nfunction getModelState(model) {\n  return cache.get(model, \"state\", stateGetter);\n}\n\n// UUID v4 generator thanks to https://gist.github.com/jed/982883\nfunction uuid(temp) {\n  return temp\n    ? // eslint-disable-next-line no-bitwise, no-mixed-operators\n      (temp ^ ((Math.random() * 16) >> (temp / 4))).toString(16)\n    : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);\n}\n\nfunction ref(fn) {\n  if (typeof fn !== \"function\") {\n    throw TypeError(`The first argument must be a function: ${typeof fn}`);\n  }\n\n  refs.add(fn);\n  return fn;\n}\n\nconst validationMap = new WeakMap();\nfunction resolveKey(Model, key, config) {\n  let defaultValue = config.model[key];\n  if (refs.has(defaultValue)) defaultValue = defaultValue();\n  let type = typeof defaultValue;\n\n  if (defaultValue instanceof String || defaultValue instanceof Number) {\n    const check = validationMap.get(defaultValue);\n    if (!check) {\n      throw TypeError(\n        stringifyModel(\n          Model,\n          `You must use primitive ${typeof defaultValue.valueOf()} value for '${key}' property of the provided model definition`,\n        ),\n      );\n    }\n\n    defaultValue = defaultValue.valueOf();\n    type = typeof defaultValue;\n\n    config.checks.set(key, check);\n  }\n\n  return { defaultValue, type };\n}\n\nfunction stringifyModel(Model, msg) {\n  return `${msg}\\n\\nModel = ${JSON.stringify(Model, null, 2)}\\n`;\n}\n\nconst resolvedPromise = Promise.resolve();\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var configs = exports.configs = new WeakMap();\nfunction setupModel(Model, nested) {\n  if (typeof Model !== \"object\" || Model === null) {\n    throw TypeError(`Model definition must be an object: ${typeof Model}`);\n  }\n\n  let config = configs.get(Model);\n\n  if (config && !config.enumerable) {\n    if (nested && !config.nested) {\n      throw TypeError(\n        stringifyModel(\n          Model,\n          \"Provided model definition for nested object already used as a root definition\",\n        ),\n      );\n    }\n\n    if (!nested && config.nested) {\n      throw TypeError(\n        stringifyModel(\n          Model,\n          \"Nested model definition cannot be used outside of the parent definition\",\n        ),\n      );\n    }\n  }\n\n  if (!config) {\n    const storage = Model[connect];\n    if (typeof storage === \"object\") Object.freeze(storage);\n\n    let invalidatePromise;\n    const enumerable = hasOwnProperty.call(Model, \"id\");\n    const external = !!storage;\n\n    const checks = new Map();\n\n    const proto = {\n      toString() {\n        return this.id || undefined;\n      },\n    };\n    const placeholder = Object.create(proto);\n\n    config = {\n      model: Model,\n      external,\n      enumerable,\n      nested: !enumerable && !external && nested,\n      placeholder: (id) => {\n        const model = Object.create(placeholder);\n        definitions.set(model, config);\n\n        if (enumerable) model.id = id;\n\n        return Object.freeze(model);\n      },\n      isInstance: (model) => Object.getPrototypeOf(model) !== placeholder,\n      invalidate: () => {\n        if (!invalidatePromise) {\n          invalidatePromise = resolvedPromise.then(() => {\n            cache.invalidate(config, config, { clearValue: true });\n            invalidatePromise = null;\n          });\n        }\n      },\n      checks,\n    };\n\n    configs.set(Model, config);\n\n    config.storage = setupStorage(config, storage || memoryStorage(config));\n\n    const transform = Object.keys(Object.freeze(Model)).map((key) => {\n      if (key !== \"id\") {\n        Object.defineProperty(placeholder, key, {\n          get() {\n            throw Error(\n              `Model instance in ${\n                getModelState(this).state\n              } state - use store.pending(), store.error(), or store.ready() guards`,\n            );\n          },\n          enumerable: true,\n        });\n      }\n\n      if (key === \"id\") {\n        if (Model[key] !== true) {\n          throw TypeError(\n            \"The 'id' property in the model definition must be set to 'true' or not defined\",\n          );\n        }\n        return (model, data, lastModel) => {\n          let id;\n          if (hasOwnProperty.call(data, \"id\")) {\n            id = stringifyId(data.id);\n          } else if (lastModel) {\n            id = lastModel.id;\n          } else {\n            id = uuid();\n          }\n\n          Object.defineProperty(model, \"id\", { value: id, enumerable: true });\n        };\n      }\n\n      const { defaultValue, type } = resolveKey(Model, key, config);\n\n      switch (type) {\n        case \"function\":\n          return (model) => {\n            Object.defineProperty(model, key, {\n              get() {\n                return cache.get(this, key, () => defaultValue(this));\n              },\n            });\n          };\n        case \"object\": {\n          if (defaultValue === null) {\n            throw TypeError(\n              `The value for the '${key}' must be an object instance: ${defaultValue}`,\n            );\n          }\n\n          const isArray = Array.isArray(defaultValue);\n\n          if (isArray) {\n            const nestedType = typeof defaultValue[0];\n\n            if (nestedType !== \"object\") {\n              const Constructor = getTypeConstructor(nestedType, key);\n              const defaultArray = Object.freeze(defaultValue.map(Constructor));\n              return (model, data, lastModel) => {\n                if (hasOwnProperty.call(data, key)) {\n                  if (!Array.isArray(data[key])) {\n                    throw TypeError(\n                      `The value for '${key}' property must be an array: ${typeof data[\n                        key\n                      ]}`,\n                    );\n                  }\n                  model[key] = Object.freeze(data[key].map(Constructor));\n                } else if (lastModel && hasOwnProperty.call(lastModel, key)) {\n                  model[key] = lastModel[key];\n                } else {\n                  model[key] = defaultArray;\n                }\n              };\n            }\n\n            const localConfig = bootstrap(defaultValue, true);\n\n            if (\n              localConfig.external &&\n              config.storage.offline &&\n              localConfig.storage.offline &&\n              localConfig.storage.offline.threshold <\n                config.storage.offline.threshold\n            ) {\n              throw Error(\n                `External nested model for '${key}' property has lower offline threshold (${localConfig.storage.offline.threshold} ms) than the parent definition (${config.storage.offline.threshold} ms)`,\n              );\n            }\n\n            if (localConfig.enumerable && defaultValue[1]) {\n              const nestedOptions = defaultValue[1];\n              if (typeof nestedOptions !== \"object\") {\n                throw TypeError(\n                  `Options for '${key}' array property must be an object instance: ${typeof nestedOptions}`,\n                );\n              }\n              if (nestedOptions.loose) {\n                config.contexts = config.contexts || new Set();\n                config.contexts.add(bootstrap(defaultValue[0]));\n              }\n            }\n            return (model, data, lastModel) => {\n              if (hasOwnProperty.call(data, key)) {\n                if (!Array.isArray(data[key])) {\n                  throw TypeError(\n                    `The value for '${key}' property must be an array: ${typeof data[\n                      key\n                    ]}`,\n                  );\n                }\n                model[key] = localConfig.create(data[key], true);\n              } else {\n                model[key] =\n                  (lastModel && lastModel[key]) ||\n                  (!localConfig.enumerable &&\n                    localConfig.create(defaultValue)) ||\n                  [];\n              }\n            };\n          }\n\n          const nestedConfig = bootstrap(defaultValue, true);\n          if (nestedConfig.enumerable || nestedConfig.external) {\n            if (\n              config.storage.offline &&\n              nestedConfig.storage.offline &&\n              nestedConfig.storage.offline.threshold <\n                config.storage.offline.threshold\n            ) {\n              throw Error(\n                `External nested model for '${key}' property has lower offline threshold (${nestedConfig.storage.offline.threshold} ms) than the parent definition (${config.storage.offline.threshold} ms)`,\n              );\n            }\n            return (model, data, lastModel) => {\n              let resultModel;\n\n              if (hasOwnProperty.call(data, key)) {\n                const nestedData = data[key];\n\n                if (typeof nestedData !== \"object\" || nestedData === null) {\n                  if (nestedData !== undefined && nestedData !== null) {\n                    resultModel = { id: nestedData };\n                  }\n                } else {\n                  const dataConfig = definitions.get(nestedData);\n                  if (dataConfig) {\n                    if (dataConfig.model !== defaultValue) {\n                      throw TypeError(\n                        \"Model instance must match the definition\",\n                      );\n                    }\n                    resultModel = nestedData;\n                  } else {\n                    const lastNestedModel = cache.getEntry(\n                      nestedConfig,\n                      data[key].id,\n                    ).value;\n                    resultModel = nestedConfig.create(\n                      nestedData,\n                      lastNestedModel &&\n                        nestedConfig.isInstance(lastNestedModel)\n                        ? lastNestedModel\n                        : undefined,\n                    );\n                    syncCache(nestedConfig, resultModel.id, resultModel);\n                  }\n                }\n              } else {\n                resultModel = lastModel && lastModel[key];\n              }\n\n              if (resultModel) {\n                const id = resultModel.id;\n                Object.defineProperty(model, key, {\n                  get() {\n                    return cache.get(this, key, () => get(defaultValue, id));\n                  },\n                  enumerable: true,\n                });\n              } else {\n                model[key] = undefined;\n              }\n            };\n          }\n\n          return (model, data, lastModel) => {\n            if (hasOwnProperty.call(data, key)) {\n              model[key] = nestedConfig.create(\n                data[key],\n                lastModel && lastModel[key],\n              );\n            } else {\n              model[key] = lastModel ? lastModel[key] : nestedConfig.create({});\n            }\n          };\n        }\n        // eslint-disable-next-line no-fallthrough\n        default: {\n          const Constructor = getTypeConstructor(type, key);\n          return (model, data, lastModel) => {\n            if (hasOwnProperty.call(data, key)) {\n              model[key] = Constructor(data[key]);\n            } else if (lastModel && hasOwnProperty.call(lastModel, key)) {\n              model[key] = lastModel[key];\n            } else {\n              model[key] = defaultValue;\n            }\n          };\n        }\n      }\n    });\n\n    config.create = function create(data, lastModel) {\n      if (data === null) return null;\n\n      if (typeof data !== \"object\") {\n        throw TypeError(`Model values must be an object instance: ${data}`);\n      }\n\n      const model = transform.reduce((acc, fn) => {\n        fn(acc, data, lastModel);\n        return acc;\n      }, Object.create(proto));\n\n      definitions.set(model, config);\n      storePointer.set(model, store);\n\n      return Object.freeze(model);\n    };\n\n    Object.freeze(placeholder);\n    Object.freeze(config);\n  }\n\n  return config;\n}\n\nconst listPlaceholderPrototype = Object.getOwnPropertyNames(\n  Array.prototype,\n).reduce((acc, key) => {\n  if (key === \"length\" || key === \"constructor\") return acc;\n\n  Object.defineProperty(acc, key, {\n    get() {\n      throw Error(\n        `Model list instance in ${\n          getModelState(this).state\n        } state - use store.pending(), store.error(), or store.ready() guards`,\n      );\n    },\n  });\n  return acc;\n}, []);\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var lists = exports.lists = new WeakMap();\nfunction setupListModel(Model, nested) {\n  let config = lists.get(Model);\n\n  if (config && !config.enumerable) {\n    if (!nested && config.nested) {\n      throw TypeError(\n        stringifyModel(\n          Model,\n          \"Nested model definition cannot be used outside of the parent definition\",\n        ),\n      );\n    }\n  }\n\n  if (!config) {\n    const modelConfig = setupModel(Model);\n\n    const contexts = new Set();\n    if (modelConfig.storage.loose) contexts.add(modelConfig);\n\n    if (!nested) {\n      if (!modelConfig.enumerable) {\n        throw TypeError(\n          stringifyModel(\n            Model,\n            \"Provided model definition does not support listing (it must be enumerable - set `id` property to `true`)\",\n          ),\n        );\n      }\n      if (!modelConfig.storage.list) {\n        throw TypeError(\n          stringifyModel(\n            Model,\n            \"Provided model definition storage does not support `list` action\",\n          ),\n        );\n      }\n    }\n\n    nested = !modelConfig.enumerable && !modelConfig.external && nested;\n\n    config = {\n      list: true,\n      nested,\n      model: Model,\n      contexts,\n      enumerable: modelConfig.enumerable,\n      external: modelConfig.external,\n      placeholder: () => {\n        const model = Object.create(listPlaceholderPrototype);\n        definitions.set(model, config);\n\n        return Object.freeze(model);\n      },\n      isInstance: (model) =>\n        Object.getPrototypeOf(model) !== listPlaceholderPrototype,\n      create(items, invalidate = false) {\n        if (items === null) return null;\n\n        const result = items.reduce((acc, data) => {\n          let id = data;\n          if (typeof data === \"object\" && data !== null) {\n            id = data.id;\n            const dataConfig = definitions.get(data);\n            let model = data;\n            if (dataConfig) {\n              if (dataConfig.model !== Model) {\n                throw TypeError(\"Model instance must match the definition\");\n              }\n            } else {\n              const lastModel =\n                modelConfig.enumerable &&\n                cache.getEntry(modelConfig, data.id).value;\n              model = modelConfig.create(\n                data,\n                lastModel && modelConfig.isInstance(lastModel)\n                  ? lastModel\n                  : undefined,\n              );\n              if (modelConfig.enumerable) {\n                id = model.id;\n                syncCache(modelConfig, id, model, invalidate);\n              }\n            }\n            if (!modelConfig.enumerable) {\n              acc.push(model);\n            }\n          } else if (!modelConfig.enumerable) {\n            throw TypeError(`Model instance must be an object: ${typeof data}`);\n          }\n          if (modelConfig.enumerable) {\n            const key = acc.length;\n            Object.defineProperty(acc, key, {\n              get() {\n                return cache.get(this, key, () => get(Model, id));\n              },\n              enumerable: true,\n            });\n          }\n          return acc;\n        }, []);\n\n        Object.defineProperty(result, \"id\", { value: items.id });\n\n        definitions.set(result, config);\n        storePointer.set(result, store);\n\n        return Object.freeze(result);\n      },\n    };\n\n    config.storage = Object.freeze({\n      ...setupStorage(config, {\n        cache: modelConfig.storage.cache,\n        get: !nested && ((id) => modelConfig.storage.list(id)),\n      }),\n      offline: modelConfig.storage.offline && {\n        threshold: modelConfig.storage.offline.threshold,\n        get: (id) => {\n          const result = modelConfig.storage.offline.get(\n            hashCode(String(stringifyId(id))),\n          );\n          return result\n            ? result.map((item) => modelConfig.storage.offline.get(item))\n            : null;\n        },\n        set: (id, values) => {\n          modelConfig.storage.offline.set(\n            hashCode(String(stringifyId(id))),\n            values.map((item) => {\n              modelConfig.storage.offline.set(item.id, item);\n              return item.id;\n            }),\n          );\n        },\n      },\n    });\n\n    lists.set(Model, Object.freeze(config));\n  }\n\n  return config;\n}\n\nfunction resolveTimestamp(h, v) {\n  return v || getCurrentTimestamp();\n}\n\nfunction stringifyId(id) {\n  switch (typeof id) {\n    case \"object\":\n      return JSON.stringify(\n        Object.keys(id)\n          .sort()\n          .reduce((acc, key) => {\n            if (typeof id[key] === \"object\" && id[key] !== null) {\n              throw TypeError(\n                `You must use primitive value for '${key}' key: ${typeof id[\n                  key\n                ]}`,\n              );\n            }\n            acc[key] = id[key];\n            return acc;\n          }, {}),\n      );\n    case \"undefined\":\n      return undefined;\n    default:\n      return String(id);\n  }\n}\n\nconst notFoundErrors = new WeakSet();\nfunction notFoundError(Model, stringId) {\n  const err = Error(\n    stringifyModel(\n      Model,\n      `Model instance ${\n        stringId !== undefined ? `with '${stringId}' id ` : \"\"\n      }does not exist`,\n    ),\n  );\n\n  notFoundErrors.add(err);\n  return err;\n}\n\nfunction mapError(model, err, suppressLog) {\n  if (suppressLog !== false && !notFoundErrors.has(err)) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n  }\n\n  return setModelState(model, \"error\", err);\n}\n\nfunction get(Model, id) {\n  const config = bootstrap(Model);\n  let stringId;\n\n  if (config.enumerable) {\n    stringId = stringifyId(id);\n\n    if (!stringId && !config.list && !draftMap.get(config)) {\n      throw TypeError(\n        stringifyModel(\n          Model,\n          `Provided model definition requires non-empty id: \"${stringId}\"`,\n        ),\n      );\n    }\n  } else if (id !== undefined) {\n    throw TypeError(\n      stringifyModel(Model, \"Provided model definition does not support id\"),\n    );\n  }\n\n  const validate = config.storage.validate;\n  if (validate) {\n    const entry = cache.getEntry(config, stringId);\n    if (entry.value && !validate(entry.value)) {\n      entry.resolved = false;\n      entry.depState = 0;\n    }\n  }\n\n  const offline = config.storage.offline;\n\n  return cache.get(config, stringId, (h, cachedModel) => {\n    if (cachedModel && pending(cachedModel)) return cachedModel;\n\n    let validContexts = true;\n    if (config.contexts) {\n      config.contexts.forEach((context) => {\n        if (\n          cache.get(context, context, resolveTimestamp) ===\n          getCurrentTimestamp()\n        ) {\n          validContexts = false;\n        }\n      });\n    }\n\n    if (validContexts && cachedModel && config.storage.validate(cachedModel)) {\n      return cachedModel;\n    }\n\n    const fallback = () =>\n      cachedModel ||\n      (offline && config.create(offline.get(stringId))) ||\n      config.placeholder(stringId);\n\n    try {\n      let result = config.storage.get(id);\n\n      if (typeof result !== \"object\" || result === null) {\n        if (offline) offline.set(stringId, null);\n        throw notFoundError(Model, stringId);\n      }\n\n      if (result instanceof Promise) {\n        result = result\n          .then((data) => {\n            if (typeof data !== \"object\" || data === null) {\n              if (offline) offline.set(stringId, null);\n              throw notFoundError(Model, stringId);\n            }\n\n            if (data.id !== stringId) data.id = stringId;\n            const model = config.create(data);\n\n            if (offline) offline.set(stringId, model);\n\n            return syncCache(config, stringId, setTimestamp(model));\n          })\n          .catch((e) => syncCache(config, stringId, mapError(fallback(), e)));\n\n        return setModelState(fallback(), \"pending\", result);\n      }\n\n      if (result.id !== stringId) result.id = stringId;\n      const model = config.create(result);\n\n      if (offline) {\n        Promise.resolve().then(() => {\n          offline.set(stringId, model);\n        });\n      }\n\n      return resolve(config, setTimestamp(model), cachedModel);\n    } catch (e) {\n      return setTimestamp(mapError(fallback(), e));\n    }\n  });\n}\n\nconst draftMap = new WeakMap();\n\nfunction getValidationError(errors) {\n  const keys = Object.keys(errors);\n  const e = Error(\n    `Model validation failed (${keys.join(\n      \", \",\n    )}) - read the details from 'errors' property`,\n  );\n\n  e.errors = errors;\n\n  return e;\n}\n\nfunction set(model, values = {}) {\n  let config = definitions.get(model);\n\n  if (config === null) {\n    model = stales.get(model);\n    config = definitions.get(model);\n  }\n\n  if (config === null) {\n    throw Error(\n      \"Provided model instance has expired. Haven't you used stale value?\",\n    );\n  }\n\n  const isInstance = !!config;\n\n  if (!config) config = bootstrap(model);\n\n  const isDraft = draftMap.get(config);\n\n  if (config.nested) {\n    throw stringifyModel(\n      config.model,\n      TypeError(\n        \"Setting provided nested model instance is not supported, use the root model instance\",\n      ),\n    );\n  }\n\n  if (config.list) {\n    throw TypeError(\"Listing model definition does not support 'set' method\");\n  }\n\n  if (!config.storage.set) {\n    throw stringifyModel(\n      config.model,\n      TypeError(\n        \"Provided model definition storage does not support 'set' method\",\n      ),\n    );\n  }\n\n  if (isInstance) {\n    const promise = pending(model);\n    if (promise) {\n      return promise.then((m) => set(m, values));\n    }\n  }\n\n  let id;\n  const setState = (state, value) => {\n    if (isInstance) {\n      setModelState(model, state, value);\n    } else {\n      const entry = cache.getEntry(config, id);\n      if (entry.value) {\n        setModelState(entry.value, state, value);\n      }\n    }\n  };\n\n  try {\n    if (\n      config.enumerable &&\n      !isInstance &&\n      (!values || typeof values !== \"object\")\n    ) {\n      throw TypeError(`Values must be an object instance: ${values}`);\n    }\n\n    if (!isDraft && values && hasOwnProperty.call(values, \"id\")) {\n      throw TypeError(`Values must not contain 'id' property: ${values.id}`);\n    }\n\n    const localModel = config.create(values, isInstance ? model : undefined);\n    const keys = values ? Object.keys(values) : [];\n\n    const errors = {};\n    const lastError = isInstance && isDraft && error(model);\n\n    let hasErrors = false;\n\n    if (localModel) {\n      config.checks.forEach((fn, key) => {\n        if (keys.indexOf(key) === -1) {\n          if (lastError && lastError.errors && lastError.errors[key]) {\n            hasErrors = true;\n            errors[key] = lastError.errors[key];\n          }\n\n          // eslint-disable-next-line eqeqeq\n          if (isDraft && localModel[key] == config.model[key]) {\n            return;\n          }\n        }\n\n        let checkResult;\n        try {\n          checkResult = fn(localModel[key], key, localModel);\n        } catch (e) {\n          checkResult = e;\n        }\n\n        if (checkResult !== true && checkResult !== undefined) {\n          hasErrors = true;\n          errors[key] = checkResult || true;\n        }\n      });\n\n      if (hasErrors && !isDraft) {\n        throw getValidationError(errors);\n      }\n    }\n\n    id = localModel ? localModel.id : model.id;\n\n    const result = Promise.resolve(\n      config.storage.set(isInstance ? id : undefined, localModel, keys),\n    )\n      .then((data) => {\n        const resultModel =\n          data === localModel ? localModel : config.create(data);\n\n        if (isInstance && resultModel && id !== resultModel.id) {\n          throw TypeError(\n            `Local and storage data must have the same id: '${id}', '${resultModel.id}'`,\n          );\n        }\n\n        let resultId = resultModel ? resultModel.id : id;\n\n        if (hasErrors && isDraft) {\n          setModelState(resultModel, \"error\", getValidationError(errors));\n        }\n\n        if (\n          isDraft &&\n          isInstance &&\n          hasOwnProperty.call(data, \"id\") &&\n          (!localModel || localModel.id !== model.id)\n        ) {\n          resultId = model.id;\n        } else if (config.storage.offline) {\n          config.storage.offline.set(resultId, resultModel);\n        }\n\n        return syncCache(\n          config,\n          resultId,\n          resultModel ||\n            mapError(\n              config.placeholder(resultId),\n              notFoundError(config.model, id),\n              false,\n            ),\n          true,\n        );\n      })\n      .catch((err) => {\n        err = err !== undefined ? err : Error(\"Undefined error\");\n        setState(\"error\", err);\n        throw err;\n      });\n\n    setState(\"pending\", result);\n\n    return result;\n  } catch (e) {\n    setState(\"error\", e);\n    return Promise.reject(e);\n  }\n}\n\nfunction sync(model, values) {\n  if (typeof values !== \"object\") {\n    throw TypeError(`Values must be an object instance: ${values}`);\n  }\n\n  let config = definitions.get(model);\n\n  if (config === null) {\n    model = stales.get(model);\n    config = definitions.get(model);\n  }\n\n  if (config === null) {\n    throw Error(\n      \"Provided model instance has expired. Haven't you used stale value?\",\n    );\n  }\n\n  if (config === undefined) {\n    if (!values) {\n      throw TypeError(\"Values must be defined for usage with model definition\");\n    }\n    config = bootstrap(model);\n    model = undefined;\n  } else if (values && hasOwnProperty.call(values, \"id\")) {\n    throw TypeError(`Values must not contain 'id' property: ${values.id}`);\n  }\n\n  if (config.list) {\n    throw TypeError(\"Listing model definition is not supported in sync method\");\n  }\n\n  const resultModel = config.create(values, model);\n  const id = values ? resultModel.id : model.id;\n\n  return syncCache(\n    config,\n    id,\n    resultModel ||\n      mapError(config.placeholder(id), notFoundError(config.model, id), false),\n  );\n}\n\nfunction clear(model, clearValue = true) {\n  if (typeof model !== \"object\" || model === null) {\n    throw TypeError(\n      `The first argument must be a model instance or a model definition: ${model}`,\n    );\n  }\n\n  let config = definitions.get(model);\n\n  if (config === null) {\n    throw Error(\n      \"Provided model instance has expired. Haven't you used stale value from the outer scope?\",\n    );\n  }\n\n  if (config) {\n    const offline = clearValue && config.storage.offline;\n    if (offline) offline.set(model.id, null);\n\n    invalidateTimestamp(model);\n    cache.invalidate(config, model.id, { clearValue, deleteEntry: true });\n  } else {\n    if (!configs.get(model) && !lists.get(model[0])) {\n      throw Error(\n        \"Model definition must be used before - passed argument is probably not a model definition\",\n      );\n    }\n    config = bootstrap(model);\n    const offline = clearValue && config.storage.offline;\n\n    cache.getEntries(config).forEach((entry) => {\n      if (offline) offline.set(entry.key, null);\n      if (entry.value) invalidateTimestamp(entry.value);\n    });\n    cache.invalidateAll(config, { clearValue, deleteEntry: true });\n  }\n}\n\nfunction pending(...models) {\n  let isPending = false;\n  const result = models.map((model) => {\n    try {\n      const { state, value } = getModelState(model);\n      if (state === \"pending\") {\n        isPending = true;\n        return value;\n      }\n    } catch (e) {} // eslint-disable-line no-empty\n\n    return Promise.resolve(model);\n  });\n\n  return isPending && (models.length > 1 ? Promise.all(result) : result[0]);\n}\n\nfunction resolveToLatest(model) {\n  model = stales.get(model) || model;\n\n  const promise = pending(model);\n\n  if (!promise) {\n    const e = error(model);\n    return e ? Promise.reject(e) : Promise.resolve(model);\n  }\n\n  return promise.then((m) => resolveToLatest(m));\n}\n\nfunction error(model, property) {\n  if (model === null || typeof model !== \"object\") return false;\n  const state = getModelState(model);\n\n  if (property !== undefined) {\n    const errors =\n      typeof state.error === \"object\" && state.error && state.error.errors;\n\n    return property === null ? !errors && state.error : errors[property];\n  }\n\n  return state.error;\n}\n\nfunction ready(...models) {\n  return (\n    models.length > 0 &&\n    models.every((model) => {\n      const config = definitions.get(model);\n      return !!(config && config.isInstance(model));\n    })\n  );\n}\n\nfunction getValuesFromModel(model, values) {\n  model = { ...model, ...values };\n  delete model.id;\n  return model;\n}\n\nfunction submit(draft, values = {}) {\n  const config = definitions.get(draft);\n  if (!config || !draftMap.has(config)) {\n    throw TypeError(`Provided model instance is not a draft: ${draft}`);\n  }\n\n  if (pending(draft)) {\n    throw Error(\"Model draft in pending state\");\n  }\n\n  const modelConfig = draftMap.get(config);\n  let result;\n\n  if (cache.getEntry(modelConfig, draft.id).value) {\n    const model = get(modelConfig.model, draft.id);\n    result = Promise.resolve(pending(model) || model).then((resolvedModel) =>\n      set(resolvedModel, getValuesFromModel(draft, values)),\n    );\n  } else {\n    result = set(modelConfig.model, getValuesFromModel(draft, values));\n  }\n\n  result = result\n    .then((resultModel) => {\n      setModelState(draft, \"ready\");\n      return set(draft, resultModel).then(() => resultModel);\n    })\n    .catch((e) => {\n      setModelState(draft, \"error\", e);\n      return Promise.reject(e);\n    });\n\n  setModelState(draft, \"pending\", result);\n\n  return result;\n}\n\nfunction required(value, key) {\n  return !!value || `${key} is required`;\n}\n\nfunction valueWithValidation(\n  defaultValue,\n  validate = required,\n  errorMessage = \"\",\n) {\n  switch (typeof defaultValue) {\n    case \"string\":\n      // eslint-disable-next-line no-new-wrappers\n      defaultValue = new String(defaultValue);\n      break;\n    case \"number\":\n      // eslint-disable-next-line no-new-wrappers\n      defaultValue = new Number(defaultValue);\n      break;\n    default:\n      throw TypeError(\n        `Default value must be a string or a number: ${typeof defaultValue}`,\n      );\n  }\n\n  let fn;\n  if (validate instanceof RegExp) {\n    fn = (value) => validate.test(value) || errorMessage;\n  } else if (typeof validate === \"function\") {\n    fn = (...args) => {\n      const result = validate(...args);\n      return result !== true && result !== undefined\n        ? errorMessage || result\n        : result;\n    };\n  } else {\n    throw TypeError(\n      `The second argument must be a RegExp instance or a function: ${typeof validate}`,\n    );\n  }\n\n  validationMap.set(defaultValue, fn);\n  return defaultValue;\n}\n\nfunction store(Model, options = {}) {\n  const config = bootstrap(Model);\n\n  if (options.id !== undefined && typeof options.id !== \"function\") {\n    const id = options.id;\n    options.id = (host) => host[id];\n  }\n\n  if (options.id && !config.enumerable) {\n    throw TypeError(\n      \"Store factory for singleton model definition does not support 'id' option\",\n    );\n  }\n\n  let draft;\n  if (options.draft) {\n    if (config.list) {\n      throw TypeError(\n        \"Draft mode is not supported for listing model definition\",\n      );\n    }\n\n    draft = bootstrap({\n      ...Model,\n      [connect]: {\n        get(id) {\n          const model = get(config.model, id);\n          return pending(model) || model;\n        },\n        set(id, values) {\n          return values === null ? { id } : values;\n        },\n      },\n    });\n\n    draftMap.set(draft, config);\n    Model = draft.model;\n  }\n\n  if (!options.id && config.enumerable) {\n    return {\n      get(host, value) {\n        const valueConfig = definitions.get(value);\n        const id = valueConfig !== undefined ? value.id : value;\n\n        if (draft && (value === undefined || value === null)) {\n          const draftModel = draft.create({}, { id: undefined });\n          syncCache(draft, undefined, draftModel, false);\n          return get(Model, undefined);\n        }\n\n        return value ? get(Model, id) : undefined;\n      },\n      set: (_, v) => v,\n      connect: draft\n        ? (host, key) => () => {\n            const model = host[key];\n            if (model && model.id) clear(model, true);\n          }\n        : undefined,\n    };\n  }\n\n  return {\n    get: (host, value) => {\n      const id = (options.id && options.id(host)) || (value && value.id);\n\n      if (draft && !id && (value === undefined || value === null)) {\n        const draftModel = draft.create({});\n        syncCache(draft, undefined, draftModel, false);\n        return get(Model, undefined);\n      }\n\n      if (config.enumerable && id === undefined) return undefined;\n\n      const nextValue = get(Model, id);\n\n      if (nextValue !== value && ready(value) && !ready(nextValue)) {\n        const tempValue = config.create(value);\n        cache.set(tempValue, \"state\", () => getModelState(nextValue));\n        return tempValue;\n      }\n\n      return nextValue;\n    },\n    set: draft && !config.enumerable ? (_, v) => v : undefined,\n    connect:\n      draft && config.enumerable\n        ? (host, key) => () => {\n            const model = host[key];\n            if (model && model.id) clear(model, true);\n          }\n        : undefined,\n  };\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = Object.freeze(\n  Object.assign(store, {\n    // storage\n    connect,\n\n    // actions\n    get,\n    set,\n    sync,\n    clear,\n\n    // guards\n    pending,\n    error,\n    ready,\n\n    // helpers\n    submit,\n    value: valueWithValidation,\n    resolve: resolveToLatest,\n    ref,\n  }),\n);\n","var __TEMP__ = require('./global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./define.js');var callbacksMap = __TEMP__['callbacksMap'];\nvar __TEMP__ = require('./cache.js');var cache = __REQUIRE_WILDCARD__(__TEMP__);\nvar __TEMP__ = require('./utils.js');var dispatch = __TEMP__['dispatch'];var walkInShadow = __TEMP__['walkInShadow'];\n\nconst connect = Symbol(\"router.connect\");\nconst configs = new WeakMap();\n\nconst flushes = new WeakMap();\nconst stacks = new WeakMap();\nconst routers = new WeakMap();\n\nlet rootRouter = null;\nconst entryPoints = new Set();\n\nlet debug = false;\nfunction setDebug(value = true) {\n  debug = !!value;\n}\n\nconst scrollMap = new WeakMap();\nconst focusMap = new WeakMap();\nfunction saveLayout(target) {\n  const focusEl = global.document.activeElement;\n  focusMap.set(target, rootRouter.contains(focusEl) && focusEl);\n\n  const map = new Map();\n\n  const rootEl = global.document.scrollingElement;\n  map.set(rootEl, { left: rootEl.scrollLeft, top: rootEl.scrollTop });\n\n  walkInShadow(target, (el) => {\n    if (el.scrollLeft || el.scrollTop) {\n      map.set(el, { left: el.scrollLeft, top: el.scrollTop });\n    }\n  });\n\n  scrollMap.set(target, map);\n}\n\nfunction focusElement(target) {\n  if (target.tabIndex === -1) {\n    const outline = target.style.outline;\n    target.tabIndex = 0;\n    target.style.outline = \"none\";\n    target.addEventListener(\n      \"blur\",\n      () => {\n        target.removeAttribute(\"tabindex\");\n        target.style.outline = outline;\n      },\n      { once: true },\n    );\n  }\n  target.focus({ preventScroll: true });\n}\n\nfunction restoreLayout(target) {\n  const activeEl = global.document.activeElement;\n\n  focusElement(\n    focusMap.get(target) ||\n      (rootRouter.contains(activeEl) ? activeEl : rootRouter),\n  );\n\n  const map = scrollMap.get(target);\n  if (map) {\n    const config = configs.get(target);\n    const state = global.history.state;\n    const entry = state.find((e) => e.id === config.id);\n    const clear = entry && entry.params.scrollToTop;\n\n    map.forEach((pos, el) => {\n      el.scrollLeft = clear ? 0 : pos.left;\n      el.scrollTop = clear ? 0 : pos.top;\n    });\n\n    scrollMap.delete(target);\n  } else {\n    const rootEl = global.document.scrollingElement;\n    rootEl.scrollLeft = 0;\n    rootEl.scrollTop = 0;\n  }\n}\n\nfunction mapUrlParam(value) {\n  return value === true ? 1 : value || \"\";\n}\n\nconst metaParams = [\"scrollToTop\"];\n\nfunction setupBrowserUrl(browserUrl, id) {\n  const [pathname, search = \"\"] = browserUrl.split(\"?\");\n\n  const searchParams = search ? search.split(\",\") : [];\n  const normalizedPathname = pathname.replace(/^\\//, \"\").split(\"/\");\n  const pathnameParams = normalizedPathname.reduce((params, name) => {\n    if (name.startsWith(\":\")) {\n      const key = name.slice(1);\n      if (searchParams.includes(key)) {\n        throw Error(`The '${key}' already used in search params`);\n      }\n      if (params.includes(key)) {\n        throw Error(`The '${key}' already used in pathname`);\n      }\n      params.push(key);\n    }\n    return params;\n  }, []);\n\n  return {\n    browserUrl,\n    pathnameParams,\n    paramsKeys: [...searchParams, ...pathnameParams],\n    url(params, strict = false) {\n      const temp = normalizedPathname.reduce((acc, part) => {\n        if (part.startsWith(\":\")) {\n          const key = part.slice(1);\n\n          if (!hasOwnProperty.call(params, key)) {\n            throw Error(`The '${key}' parameter must be defined for <${id}>`);\n          }\n\n          part = mapUrlParam(params[key]);\n        }\n\n        return `${acc}/${part}`;\n      });\n\n      const url = new URL(temp, global.location.origin);\n\n      Object.keys(params).forEach((key) => {\n        if (\n          pathnameParams.includes(key) ||\n          (strict && (metaParams.includes(key) || !searchParams.includes(key)))\n        ) {\n          return;\n        }\n\n        url.searchParams.append(key, mapUrlParam(params[key]));\n      });\n\n      return url;\n    },\n    match(url) {\n      const params = {};\n      const temp = url.pathname.replace(/^\\//, \"\").split(\"/\");\n\n      if (temp.length !== normalizedPathname.length) return null;\n\n      for (let i = 0; i < temp.length; i += 1) {\n        const part = temp[i];\n        const normalizedPart = normalizedPathname[i];\n\n        if (normalizedPart.startsWith(\":\")) {\n          const key = normalizedPart.slice(1);\n          params[key] = part;\n        } else if (part !== normalizedPart) {\n          return null;\n        }\n      }\n\n      url.searchParams.forEach((value, key) => {\n        params[key] = value;\n      });\n\n      return params;\n    },\n  };\n}\n\nfunction hasInStack(config, target) {\n  return config.stack.some((temp) => {\n    if (temp === target) return true;\n    return hasInStack(temp, target);\n  });\n}\n\nfunction addEntryPoint(config) {\n  if (config.browserUrl) {\n    entryPoints.add(config);\n  }\n  config.stack.forEach(addEntryPoint);\n}\n\nfunction setupViews(views, options, parent = null, nestedParent = null) {\n  if (typeof views === \"function\") views = views();\n  views = [].concat(views);\n\n  return views.map((hybrids) => {\n    const config = configs.get(hybrids);\n\n    if (config && hasInStack(config, parent)) {\n      throw Error(\n        `<${config.id}> cannot be in the stack of <${parent.id}>, as it is an ancestor in the stack tree`,\n      );\n    }\n\n    // eslint-disable-next-line no-use-before-define\n    return setupView(hybrids, options, parent, nestedParent);\n  });\n}\n\nfunction getNestedRouterOptions(hybrids, config) {\n  const nestedRouters = Object.values(hybrids)\n    .map((desc) => routers.get(desc))\n    .filter((d) => d);\n\n  if (nestedRouters.length) {\n    if (nestedRouters.length > 1) {\n      throw TypeError(\n        `<${config.id}> must contain at most one nested router, found: ${nestedRouters.length}`,\n      );\n    }\n\n    if (config.dialog) {\n      throw TypeError(\n        `Nested routers are not supported in dialogs. Remove the router property definition from <${config.id}>`,\n      );\n    }\n\n    if (config.browserUrl) {\n      throw TypeError(\n        `A view with nested router must not have the url option. Remove the url option from <${config.id}>`,\n      );\n    }\n  }\n  return nestedRouters[0];\n}\n\nfunction getConfigById(id) {\n  const Constructor = global.customElements.get(id);\n  return configs.get(Constructor);\n}\n\nfunction setupView(hybrids, routerOptions, parent, nestedParent) {\n  const id = hybrids.tag;\n  let config = getConfigById(id);\n\n  if (config && config.hybrids !== hybrids) {\n    config = null;\n  }\n\n  if (!config) {\n    const Constructor = global.customElements.get(id);\n\n    if (!Constructor || Constructor.hybrids !== hybrids) {\n      throw Error(\n        `<${id}> view must be defined by 'define()' function before it can be used in router factory`,\n      );\n    }\n\n    let browserUrl = null;\n\n    const options = {\n      dialog: false,\n      guard: false,\n      multiple: false,\n      replace: false,\n      ...hybrids[connect],\n    };\n\n    const callbacks = callbacksMap.get(Constructor);\n\n    if (!nestedParent) {\n      callbacks.push(restoreLayout);\n    }\n\n    if (options.dialog) {\n      callbacks.push((host) => {\n        const goBackOnEscKey = (event) => {\n          if (event.key === \"Escape\") {\n            event.stopPropagation();\n            global.history.go(-1);\n          }\n        };\n\n        const focusDialog = () => {\n          focusElement(host);\n        };\n\n        const prevActiveEl = global.document.activeElement;\n        const root = rootRouter;\n\n        root.addEventListener(\"focusin\", focusDialog);\n        host.addEventListener(\"focusout\", focusDialog);\n        host.addEventListener(\"keydown\", goBackOnEscKey);\n\n        focusElement(host);\n\n        return () => {\n          root.removeEventListener(\"focusin\", focusDialog);\n          host.removeEventListener(\"focusout\", focusDialog);\n          host.removeEventListener(\"keydown\", goBackOnEscKey);\n\n          focusElement(prevActiveEl);\n        };\n      });\n    }\n\n    const writableParams = [];\n    Object.keys(Constructor.prototype).forEach((key) => {\n      const desc = Object.getOwnPropertyDescriptor(Constructor.prototype, key);\n      if (desc.set) writableParams.push(key);\n    });\n\n    if (options.url) {\n      if (options.dialog) {\n        throw Error(\n          `The 'url' option is not supported for dialogs - remove it from <${id}>`,\n        );\n      }\n      if (typeof options.url !== \"string\") {\n        throw TypeError(\n          `The 'url' option in <${id}> must be a string: ${typeof options.url}`,\n        );\n      }\n      browserUrl = setupBrowserUrl(options.url, id);\n\n      browserUrl.paramsKeys.forEach((key) => {\n        const desc = Object.getOwnPropertyDescriptor(\n          Constructor.prototype,\n          key,\n        );\n        if (!desc || !desc.set) {\n          throw Error(\n            `'${key}' parameter from the url is not ${\n              desc ? \"writable\" : \"defined\"\n            } in <${id}>`,\n          );\n        }\n      });\n    }\n\n    const stateParams = writableParams.filter(\n      (k) => !routerOptions.params.includes(k) && !metaParams.includes(k),\n    );\n\n    callbacksMap.get(Constructor).unshift((_) =>\n      cache.observe(\n        _,\n        connect,\n        (host) =>\n          stateParams.reduce((acc, key) => {\n            const value = mapUrlParam(host[key]).toString();\n            if (value !== undefined && value !== hybrids[key]) {\n              acc[key] = String(value);\n            }\n            return acc;\n          }, {}),\n        (host, params, lastParams) => {\n          if (!lastParams) return;\n\n          const state = global.history.state;\n          let entry = state[0];\n          while (entry.id !== id && entry.nested) entry = entry.nested;\n\n          params = { ...entry.params, ...params };\n\n          global.history.replaceState(\n            [config.getEntry(params), ...state.slice(1)],\n            \"\",\n            browserUrl ? config.url(params, true) : \"\",\n          );\n        },\n      ),\n    );\n\n    let guard;\n    if (options.guard) {\n      guard = () => {\n        try {\n          return options.guard();\n        } catch (e) {\n          console.error(e);\n          return false;\n        }\n      };\n    }\n\n    config = {\n      id,\n      hybrids,\n      dialog: options.dialog,\n      multiple: options.multiple,\n      replace: options.replace,\n      guard,\n      parent,\n      nestedParent,\n      nestedRoots: undefined,\n      parentsWithGuards: undefined,\n      stack: [],\n      ...(browserUrl || {\n        url(params) {\n          const url = new URL(\"\", global.location.origin);\n\n          Object.keys(params).forEach((key) => {\n            url.searchParams.append(key, mapUrlParam(params[key]));\n          });\n\n          return new URL(\n            `${routerOptions.url}#@${id}${url.search}`,\n            global.location.origin,\n          );\n        },\n        match(url) {\n          const params = {};\n          url.searchParams.forEach((value, key) => {\n            if (writableParams.includes(key) || metaParams.includes(key))\n              params[key] = value;\n          });\n\n          return params;\n        },\n      }),\n      create() {\n        const el = new Constructor();\n        configs.set(el, config);\n\n        return el;\n      },\n      getEntry(params = {}, other) {\n        const entryParams = Object.keys(params).reduce((acc, key) => {\n          if (writableParams.includes(key)) {\n            acc[key] = params[key];\n          }\n\n          return acc;\n        }, {});\n\n        const entry = { id, params: entryParams, ...other };\n        const guardConfig = config.parentsWithGuards.find((c) => !c.guard());\n\n        if (guardConfig) {\n          return guardConfig.getEntry(params, { from: entry });\n        }\n\n        if (config.guard && config.guard()) {\n          return { ...config.stack[0].getEntry(params) };\n        }\n\n        if (config.nestedParent) {\n          return config.nestedParent.getEntry(params, { nested: entry });\n        }\n\n        metaParams.forEach((key) => {\n          if (hasOwnProperty.call(params, key)) {\n            entry.params[key] = params[key];\n          }\n        });\n\n        return entry;\n      },\n    };\n\n    configs.set(hybrids, config);\n    configs.set(Constructor, config);\n\n    if (parent && !parent.stack.includes(config)) {\n      parent.stack.push(config);\n    }\n\n    if (options.stack) {\n      if (options.dialog) {\n        throw Error(\n          `The 'stack' option is not supported for dialogs - remove it from <${id}>`,\n        );\n      }\n      setupViews(options.stack, routerOptions, config, nestedParent);\n    }\n  } else {\n    config.parent = parent;\n    config.nestedParent = nestedParent;\n  }\n\n  if (!parent) {\n    addEntryPoint(config);\n  }\n\n  config.parentsWithGuards = [];\n  while (parent) {\n    if (parent.guard) config.parentsWithGuards.unshift(parent);\n    parent = parent.parent;\n  }\n\n  const nestedRouterOptions = getNestedRouterOptions(hybrids, config);\n\n  if (nestedRouterOptions) {\n    config.nestedRoots = setupViews(\n      nestedRouterOptions.views,\n      { ...routerOptions, ...nestedRouterOptions },\n      config,\n      config,\n    );\n\n    config.stack = config.stack.concat(config.nestedRoots);\n  }\n\n  return config;\n}\n\nfunction getUrl(view, params = {}) {\n  const config = configs.get(view);\n  return config ? config.url(params) : \"\";\n}\n\nfunction getAllEntryParams(entry) {\n  const params = {};\n  while (entry) {\n    Object.assign(params, entry.params);\n    entry = entry.nested;\n  }\n\n  return params;\n}\n\nfunction getBackUrl({ nested = false, scrollToTop = false } = {}) {\n  const state = global.history.state;\n  if (!state) return \"\";\n\n  if (state.length > 1) {\n    const entry = state[0];\n    let i = 1;\n    let prevEntry = state[i];\n    if (nested) {\n      while (prevEntry.nested) {\n        prevEntry = prevEntry.nested;\n      }\n    } else {\n      while (entry.id === prevEntry.id && i < state.length - 1) {\n        i += 1;\n        prevEntry = state[i];\n      }\n    }\n\n    const params = getAllEntryParams(state[i]);\n\n    if (scrollToTop) {\n      params.scrollToTop = true;\n    } else {\n      delete params.scrollToTop;\n    }\n\n    return getConfigById(prevEntry.id).url(params);\n  }\n\n  let entry = state[0];\n\n  if (nested) {\n    while (entry.nested) {\n      entry = entry.nested;\n    }\n  }\n\n  let config = getConfigById(entry.id).parent;\n\n  if (config) {\n    while (config && config.guard) {\n      config = config.parent;\n    }\n\n    if (config) {\n      return config.url(getAllEntryParams(state[0]));\n    }\n  }\n\n  return \"\";\n}\n\nfunction getGuardUrl(params = {}) {\n  const state = global.history.state;\n  if (!state) return \"\";\n\n  const entry = state[0];\n\n  if (entry.from) {\n    const config = getConfigById(entry.from.id);\n    return config.url({ ...entry.from.params, ...params });\n  }\n\n  const config = getConfigById(entry.id);\n  return config.stack[0] ? config.stack[0].url(params) : \"\";\n}\n\nfunction getCurrentUrl(params) {\n  const state = global.history.state;\n  if (!state) return \"\";\n\n  let entry = state[0];\n  while (entry.nested) entry = entry.nested;\n\n  const config = getConfigById(entry.id);\n  return config.url({ ...entry.params, ...params });\n}\n\nfunction active(views, { stack = false } = {}) {\n  const state = global.history.state;\n  if (!state) return false;\n\n  views = [].concat(views);\n\n  return views.some((view) => {\n    const config = configs.get(view);\n    if (!config) {\n      throw TypeError(`Provided view is not connected to the router: ${view}`);\n    }\n\n    let entry = state[0];\n    while (entry) {\n      const target = getConfigById(entry.id);\n      if (target === config || (stack && hasInStack(config, target))) {\n        return true;\n      }\n      entry = entry.nested;\n    }\n\n    return false;\n  });\n}\n\nfunction getEntryFromURL(url) {\n  let config;\n\n  const [pathname, search] = url.hash.split(\"?\");\n  if (pathname && pathname.match(/^#@.+-.+/)) {\n    config = getConfigById(pathname.split(\"@\")[1]);\n    url = new URL(`?${search}`, global.location.origin);\n  }\n\n  if (!config) {\n    for (const entryPoint of entryPoints) {\n      const params = entryPoint.match(url);\n      if (params) return entryPoint.getEntry(params);\n    }\n\n    return null;\n  }\n\n  return config.getEntry(config.match(url));\n}\n\nfunction handleNavigate(event) {\n  if (event.defaultPrevented) return;\n\n  let url;\n\n  if (event.type === \"click\") {\n    if (event.ctrlKey || event.metaKey) return;\n    const anchorEl = event\n      .composedPath()\n      .find((el) => el instanceof global.HTMLAnchorElement);\n\n    if (anchorEl) {\n      url = new URL(anchorEl.href, global.location.origin);\n    }\n  } else {\n    url = new URL(event.target.action, global.location.origin);\n  }\n\n  if (url && url.origin === global.location.origin) {\n    const entry = getEntryFromURL(url);\n    if (entry) {\n      event.preventDefault();\n\n      dispatch(rootRouter, \"navigate\", {\n        bubbles: true,\n        detail: { entry, url },\n      });\n    }\n  }\n}\n\nlet activePromise;\nfunction resolveEvent(event, promise) {\n  event.preventDefault();\n  activePromise = promise;\n\n  const path = event.composedPath();\n  const pseudoEvent = {\n    type: event.type,\n    ctrlKey: event.ctrlKey,\n    metaKey: event.metaKey,\n    target: event.target,\n    defaultPrevented: false,\n    preventDefault: () => {},\n    composedPath: () => path,\n  };\n\n  return promise.then(() => {\n    if (promise === activePromise) {\n      global.requestAnimationFrame(() => {\n        handleNavigate(pseudoEvent);\n      });\n      activePromise = null;\n    }\n  });\n}\n\nfunction resolveStack(host, state, options) {\n  let stack = stacks.get(host);\n  const reducedState = state.reduce((acc, entry, index) => {\n    if (\n      index === 0 ||\n      state[index - 1].id !== entry.id ||\n      getConfigById(entry.id).multiple\n    ) {\n      acc.push(entry);\n    }\n    return acc;\n  }, []);\n  const offset = stack.length - reducedState.length;\n\n  stack = reducedState.map((entry, index) => {\n    const prevView = stack[index + offset];\n    const config = getConfigById(entry.id);\n    let nextView;\n\n    if (prevView) {\n      const prevConfig = configs.get(prevView);\n      if (config.id !== prevConfig.id || (index === 0 && config.replace)) {\n        return config.create();\n      }\n      nextView = prevView;\n    } else {\n      nextView = config.create();\n    }\n\n    if (index === 0) {\n      if (nextView === prevView) {\n        cache.unsuspend(nextView);\n\n        if (offset === 0 && host === rootRouter && entry.params.scrollToTop) {\n          restoreLayout(nextView);\n        }\n      }\n    }\n\n    return nextView;\n  });\n\n  stacks.set(host, stack);\n\n  const view = stack[0];\n  const flush = flushes.get(view);\n\n  Object.entries(state[0].params).forEach(([key, value]) => {\n    if (key in view) view[key] = value;\n  });\n\n  options.params.forEach((key) => {\n    if (key in view) view[key] = host[key];\n  });\n\n  if (flush) flush();\n}\n\nfunction getEntryOffset(entry) {\n  const state = global.history.state.reduce((acc, e, index) => {\n    let i = 0;\n\n    while (e) {\n      acc[i] = acc[i] || [];\n      acc[i][index] = e;\n      e = e.nested;\n      i += 1;\n    }\n\n    return acc;\n  }, []);\n\n  let offset = 0;\n  let i = 0;\n  while (entry) {\n    const config = getConfigById(entry.id);\n    let j = offset;\n\n    for (; j < state[i].length; j += 1) {\n      const e = state[i][j];\n\n      if (config.dialog) {\n        return e.id !== entry.id ? -1 : offset;\n      }\n\n      if (e.id === entry.id) {\n        if (config.multiple) {\n          if (\n            (config.pathnameParams &&\n              config.pathnameParams.every(\n                (key) => entry.params[key] === e.params[key],\n              )) ||\n            Object.entries(entry.params).every(\n              ([key, value]) => e.params[key] === value,\n            )\n          ) {\n            offset = j;\n            break;\n          }\n        } else {\n          offset = j;\n          break;\n        }\n      }\n\n      const c = getConfigById(e.id);\n      if (hasInStack(c, config)) {\n        if (config.multiple && state[i][0].id === entry.id) {\n          offset -= 1;\n          break;\n        }\n\n        if (j > 0) {\n          offset = j - 1;\n          break;\n        } else {\n          return c.guard ? 0 : -1;\n        }\n      }\n    }\n\n    if (j === state[i].length) {\n      offset = state[i].length - 1;\n    }\n\n    entry = entry.nested;\n    i += 1;\n  }\n\n  return offset;\n}\n\nfunction connectRootRouter(host, invalidate, options) {\n  function restoreScrollRestoration() {\n    if (global.history.scrollRestoration === \"manual\") {\n      global.history.scrollRestoration = \"auto\";\n    }\n  }\n\n  function flush() {\n    resolveStack(host, global.history.state, options);\n    invalidate();\n\n    global.requestAnimationFrame(restoreScrollRestoration);\n  }\n\n  function navigateBack(offset, entry, nextUrl) {\n    const stateLength = global.history.state.length;\n    const targetEntry = global.history.state[offset];\n    const pushOffset = offset < stateLength - 1 && stateLength > 2 ? 1 : 0;\n\n    if (targetEntry && entry.id === targetEntry.id) {\n      entry = { ...targetEntry, ...entry };\n    }\n\n    offset = -(offset + pushOffset);\n\n    const replace = (popStateEvent) => {\n      if (popStateEvent) {\n        global.removeEventListener(\"popstate\", replace);\n        global.addEventListener(\"popstate\", flush);\n      }\n\n      const state = global.history.state;\n      const method = pushOffset ? \"pushState\" : \"replaceState\";\n      const nextState = [entry, ...state.slice(pushOffset ? 0 : 1)];\n\n      if (pushOffset) {\n        global.history.scrollRestoration = \"manual\";\n      }\n\n      global.history[method](nextState, \"\", nextUrl);\n\n      flush();\n    };\n\n    if (offset) {\n      global.removeEventListener(\"popstate\", flush);\n      global.addEventListener(\"popstate\", replace);\n\n      global.history.go(offset);\n    } else {\n      replace();\n    }\n  }\n\n  function navigate(entry) {\n    const state = global.history.state;\n\n    let nestedEntry = entry;\n    while (nestedEntry.nested) nestedEntry = nestedEntry.nested;\n    const nestedConfig = getConfigById(nestedEntry.id);\n\n    const url = nestedConfig.browserUrl\n      ? nestedConfig.url(nestedEntry.params, true)\n      : options.url;\n    const offset = getEntryOffset(entry);\n\n    if (offset > -1) {\n      navigateBack(offset, entry, url);\n    } else {\n      let stack = stacks.get(host);\n      saveLayout(stack[0]);\n\n      while (stack && stack[0]) {\n        cache.suspend(stack[0]);\n        stack = stacks.get(stack[0]);\n      }\n\n      global.history.scrollRestoration = \"manual\";\n      global.history.pushState([entry, ...state], \"\", url);\n\n      flush();\n    }\n  }\n\n  function executeNavigate(event) {\n    navigate(event.detail.entry);\n  }\n\n  if (rootRouter) {\n    throw Error(\n      `An element with root router already connected to the document: <${rootRouter.tagName.toLowerCase()}>`,\n    );\n  }\n\n  let roots;\n  try {\n    roots = setupViews(options.views, options);\n    rootRouter = host;\n    flushes.set(host, flush);\n  } catch (e) {\n    console.error(\n      `Error while connecting router in <${host.tagName.toLowerCase()}>:`,\n    );\n    throw e;\n  }\n\n  const state = global.history.state;\n\n  if (!state) {\n    const entry =\n      getEntryFromURL(new URL(global.location.href)) || roots[0].getEntry();\n\n    global.history.replaceState([entry], \"\", options.url);\n    flush();\n  } else {\n    const stack = stacks.get(host);\n\n    let i;\n    for (i = state.length - 1; i >= 0; i -= 1) {\n      let entry = state[i];\n      while (entry) {\n        const config = getConfigById(entry.id);\n        if (\n          !config ||\n          (config.dialog && stack.length === 0) ||\n          (!roots.includes(config) && !roots.some((c) => hasInStack(c, config)))\n        ) {\n          break;\n        }\n        entry = entry.nested;\n      }\n      if (entry) break;\n    }\n\n    if (i > -1) {\n      const lastValidEntry = state[i + 1];\n      navigateBack(\n        state.length - i - 1,\n        lastValidEntry || roots[0].getEntry(state[0].params),\n        options.url,\n      );\n    } else {\n      let entry = state[0];\n      while (entry.nested) entry = entry.nested;\n\n      const nestedConfig = getConfigById(entry.id);\n      const resultEntry = nestedConfig.getEntry(entry.params);\n      navigate(resultEntry);\n    }\n  }\n\n  global.addEventListener(\"popstate\", flush);\n\n  host.addEventListener(\"click\", handleNavigate);\n  host.addEventListener(\"submit\", handleNavigate);\n  host.addEventListener(\"navigate\", executeNavigate);\n\n  return () => {\n    global.removeEventListener(\"popstate\", flush);\n\n    host.removeEventListener(\"click\", handleNavigate);\n    host.removeEventListener(\"submit\", handleNavigate);\n    host.removeEventListener(\"navigate\", executeNavigate);\n\n    entryPoints.clear();\n    rootRouter = null;\n  };\n}\n\nfunction connectNestedRouter(host, invalidate, options) {\n  const config = configs.get(host);\n\n  function getNestedState() {\n    return global.history.state\n      .map((entry) => {\n        while (entry) {\n          if (entry.id === config.id) return entry.nested;\n          entry = entry.nested;\n        }\n        return entry;\n      })\n      .filter((e) => e);\n  }\n\n  function flush() {\n    resolveStack(host, getNestedState(), options);\n    invalidate();\n  }\n\n  if (!getNestedState()[0]) {\n    const state = global.history.state;\n    global.history.replaceState(\n      [config.nestedRoots[0].getEntry(state[0].params), ...state.slice(1)],\n      \"\",\n    );\n  }\n\n  flush();\n  flushes.set(host, flush);\n}\n\nfunction router(views, options) {\n  options = {\n    url: global.location.href.replace(/#.*$/, \"\"),\n    params: [],\n    ...options,\n    views,\n  };\n\n  const desc = {\n    get: (host) => {\n      const stack = stacks.get(host) || [];\n      return stack\n        .slice(0, stack.findIndex((el) => !configs.get(el).dialog) + 1)\n        .reverse();\n    },\n    connect: (host, key, invalidate) => {\n      options.params.forEach((param) => {\n        if (!(param in host)) {\n          throw Error(\n            `Property '${param}' for global parameters is not defined in <${host.tagName.toLowerCase()}>`,\n          );\n        }\n      });\n\n      if (!stacks.has(host)) stacks.set(host, []);\n\n      if (configs.has(host)) {\n        return connectNestedRouter(host, invalidate, options);\n      }\n\n      return connectRootRouter(host, invalidate, options);\n    },\n    observe:\n      debug &&\n      ((host, value, lastValue) => {\n        const index = value.length - 1;\n        const view = value[index];\n\n        if (lastValue && view === lastValue[index]) return;\n\n        let config = configs.get(host);\n        let entry = global.history.state[0];\n        let key = 0;\n\n        while (config) {\n          key += 1;\n          entry = entry.nested;\n          config = config.nestedParent;\n        }\n\n        console.groupCollapsed(\n          `[${host.tagName.toLowerCase()}]: navigated to <${\n            entry.id\n          }> ($$${key})`,\n        );\n\n        Object.entries(entry.params).forEach(([k, v]) =>\n          console.log(`%c${k}:`, \"font-weight: bold\", v),\n        );\n\n        console.groupEnd();\n\n        global[`$$${key}`] = view;\n      }),\n  };\n\n  routers.set(desc, options);\n  return desc;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = Object.freeze(\n  Object.assign(router, {\n    connect,\n    debug: setDebug,\n    url: getUrl,\n    backUrl: getBackUrl,\n    guardUrl: getGuardUrl,\n    currentUrl: getCurrentUrl,\n    resolve: resolveEvent,\n    active,\n  }),\n);\n","var __TEMP__ = require('./core.js');var compileTemplate = __TEMP__['compileTemplate'];var getPlaceholder = __TEMP__['getPlaceholder'];\nvar __TEMP__ = require('./helpers.js');var helpers = __REQUIRE_WILDCARD__(__TEMP__);\n\nconst PLACEHOLDER = getPlaceholder();\nconst SVG_PLACEHOLDER = getPlaceholder(\"svg\");\nconst STYLE_IMPORT_REGEXP = /@import/;\n\nconst templatesMap = new Map();\nconst stylesMap = new WeakMap();\n\nconst methods = {\n  key(id) {\n    this.id = id;\n    return this;\n  },\n  style(...styles) {\n    stylesMap.set(\n      this,\n      (stylesMap.get(this) || []).concat(styles.filter((style) => style)),\n    );\n    return this;\n  },\n  css(parts, ...args) {\n    stylesMap.set(\n      this,\n      (stylesMap.get(this) || []).concat(\n        parts.reduce(\n          (acc, part, index) => `${acc}${part}${args[index] || \"\"}`,\n          \"\",\n        ),\n      ),\n    );\n    return this;\n  },\n};\n\nfunction create(parts, args, isSVG) {\n  const createTemplate = (host, target = host) => {\n    const styles = stylesMap.get(createTemplate);\n    let hasAdoptedStyleSheets;\n    let id = parts.join(PLACEHOLDER);\n\n    if (styles) {\n      const joinedStyles = styles.join(PLACEHOLDER);\n      hasAdoptedStyleSheets =\n        !!target.adoptedStyleSheets && !STYLE_IMPORT_REGEXP.test(joinedStyles);\n      if (!hasAdoptedStyleSheets) id += joinedStyles;\n    }\n\n    if (isSVG) id += SVG_PLACEHOLDER;\n\n    let render = templatesMap.get(id);\n    if (!render) {\n      render = compileTemplate(parts, isSVG, !hasAdoptedStyleSheets && styles);\n      templatesMap.set(id, render);\n    }\n\n    render(host, target, args, hasAdoptedStyleSheets && styles);\n  };\n\n  return Object.assign(createTemplate, methods);\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function html(parts, ...args) {\n  return create(parts, args);\n};exports.html = html\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function svg(parts, ...args) {\n  return create(parts, args, true);\n};exports.svg = svg\n\nObject.assign(html, helpers);\nObject.assign(svg, helpers);\n","var __TEMP__ = require('../global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../utils.js');var stringifyElement = __TEMP__['stringifyElement'];var shadyCSS = __TEMP__['shadyCSS'];var probablyDevMode = __TEMP__['probablyDevMode'];\nvar __TEMP__ = require('./utils.js');var dataMap = __TEMP__['dataMap'];var removeTemplate = __TEMP__['removeTemplate'];\n\nvar __TEMP__ = require('./resolvers/value.js');var resolveValue = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./resolvers/property.js');var resolveProperty = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst TIMESTAMP = Date.now();\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var getPlaceholder = exports.getPlaceholder = (id = 0) => `{{h-${TIMESTAMP}-${id}}}`;\n\nconst PLACEHOLDER_REGEXP_TEXT = getPlaceholder(\"(\\\\d+)\");\nconst PLACEHOLDER_REGEXP_EQUAL = new RegExp(`^${PLACEHOLDER_REGEXP_TEXT}$`);\nconst PLACEHOLDER_REGEXP_ALL = new RegExp(PLACEHOLDER_REGEXP_TEXT, \"g\");\n\nconst preparedTemplates = new WeakMap();\n\n/* istanbul ignore next */\nfunction applyShadyCSS(template, tagName) {\n  if (!tagName) return template;\n\n  return shadyCSS((shady) => {\n    let map = preparedTemplates.get(template);\n    if (!map) {\n      map = new Map();\n      preparedTemplates.set(template, map);\n    }\n\n    let clone = map.get(tagName);\n\n    if (!clone) {\n      clone = global.document.createElement(\"template\");\n      clone.content.appendChild(template.content.cloneNode(true));\n\n      map.set(tagName, clone);\n\n      const styles = clone.content.querySelectorAll(\"style\");\n\n      Array.from(styles).forEach((style) => {\n        const count = style.childNodes.length + 1;\n        for (let i = 0; i < count; i += 1) {\n          style.parentNode.insertBefore(\n            global.document.createTextNode(getPlaceholder()),\n            style,\n          );\n        }\n      });\n\n      shady.prepareTemplate(clone, tagName.toLowerCase());\n    }\n    return clone;\n  }, template);\n}\n\nfunction createSignature(parts, styles) {\n  let signature = parts.reduce((acc, part, index) => {\n    if (index === 0) {\n      return part;\n    }\n\n    if (\n      parts\n        .slice(index)\n        .join(\"\")\n        .match(/^\\s*<\\/\\s*(table|tr|thead|tbody|tfoot|colgroup)>/)\n    ) {\n      return `${acc}<!--${getPlaceholder(index - 1)}-->${part}`;\n    }\n    return acc + getPlaceholder(index - 1) + part;\n  }, \"\");\n\n  if (styles) {\n    signature += `<style>\\n${styles.join(\"\\n/*------*/\\n\")}\\n</style>`;\n  }\n\n  return signature;\n}\n\nfunction getPropertyName(string) {\n  return string\n    .replace(/\\s*=\\s*['\"]*$/g, \"\")\n    .split(/\\s+/)\n    .pop();\n}\n\nfunction replaceComments(fragment) {\n  const iterator = global.document.createNodeIterator(\n    fragment,\n    global.NodeFilter.SHOW_COMMENT,\n    null,\n    false,\n  );\n  let node;\n  // eslint-disable-next-line no-cond-assign\n  while ((node = iterator.nextNode())) {\n    if (PLACEHOLDER_REGEXP_EQUAL.test(node.textContent)) {\n      node.parentNode.insertBefore(\n        global.document.createTextNode(node.textContent),\n        node,\n      );\n      node.parentNode.removeChild(node);\n    }\n  }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function createInternalWalker(context) {\n  let node;\n\n  return {\n    get currentNode() {\n      return node;\n    },\n    nextNode() {\n      if (node === undefined) {\n        node = context.childNodes[0];\n      } else if (node.childNodes.length) {\n        node = node.childNodes[0];\n      } else if (node.nextSibling) {\n        node = node.nextSibling;\n      } else {\n        let parentNode = node.parentNode;\n        node = parentNode.nextSibling;\n\n        while (!node && parentNode !== context) {\n          parentNode = parentNode.parentNode;\n          node = parentNode.nextSibling;\n        }\n      }\n\n      return !!node;\n    },\n  };\n};exports.createInternalWalker = createInternalWalker\n\nfunction createExternalWalker(context) {\n  return global.document.createTreeWalker(\n    context,\n    // eslint-disable-next-line no-bitwise\n    global.NodeFilter.SHOW_ELEMENT | global.NodeFilter.SHOW_TEXT,\n    null,\n    false,\n  );\n}\n\n/* istanbul ignore next */\nconst createWalker =\n  typeof global.ShadyDOM === \"object\" && global.ShadyDOM.inUse\n    ? createInternalWalker\n    : createExternalWalker;\n\nconst styleSheetsMap = new Map();\n\nfunction normalizeWhitespace(input, startIndent = 0) {\n  input = input.replace(/(^[\\n\\s\\t ]+)|([\\n\\s\\t ]+$)+/g, \"\");\n\n  let i = input.indexOf(\"\\n\");\n  if (i > -1) {\n    let indent = 0 - startIndent - 2;\n    for (i += 1; input[i] === \" \" && i < input.length; i += 1) {\n      indent += 1;\n    }\n    return input.replace(/\\n +/g, (t) =>\n      t.substr(0, Math.max(t.length - indent, 1)),\n    );\n  }\n\n  return input;\n}\n\nfunction beautifyTemplateLog(input, index) {\n  const placeholder = getPlaceholder(index);\n\n  const output = normalizeWhitespace(input)\n    .split(\"\\n\")\n    .filter((i) => i)\n    .map((line) => {\n      const startIndex = line.indexOf(placeholder);\n\n      if (startIndex > -1) {\n        return `| ${line}\\n--${\"-\".repeat(startIndex)}${\"^\".repeat(6)}`;\n      }\n\n      return `| ${line}`;\n    })\n    .join(\"\\n\")\n    // eslint-disable-next-line no-template-curly-in-string\n    .replace(PLACEHOLDER_REGEXP_ALL, \"${...}\");\n\n  return `${output}`;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function compileTemplate(rawParts, isSVG, styles) {\n  const template = global.document.createElement(\"template\");\n  const parts = [];\n\n  const signature = createSignature(rawParts, styles);\n  template.innerHTML = isSVG ? `<svg>${signature}</svg>` : signature;\n\n  if (isSVG) {\n    const svgRoot = template.content.firstChild;\n    template.content.removeChild(svgRoot);\n    Array.from(svgRoot.childNodes).forEach((node) =>\n      template.content.appendChild(node),\n    );\n  }\n\n  replaceComments(template.content);\n\n  const compileWalker = createWalker(template.content);\n  const notDefinedElements = [];\n  let compileIndex = 0;\n\n  while (compileWalker.nextNode()) {\n    const node = compileWalker.currentNode;\n\n    if (node.nodeType === global.Node.TEXT_NODE) {\n      const text = node.textContent;\n\n      if (!text.match(PLACEHOLDER_REGEXP_EQUAL)) {\n        const results = text.match(PLACEHOLDER_REGEXP_ALL);\n        if (results) {\n          let currentNode = node;\n          results\n            .reduce(\n              (acc, placeholder) => {\n                const [before, next] = acc.pop().split(placeholder);\n                if (before) acc.push(before);\n                acc.push(placeholder);\n                if (next) acc.push(next);\n                return acc;\n              },\n              [text],\n            )\n            .forEach((part, index) => {\n              if (index === 0) {\n                currentNode.textContent = part;\n              } else {\n                currentNode = currentNode.parentNode.insertBefore(\n                  global.document.createTextNode(part),\n                  currentNode.nextSibling,\n                );\n              }\n            });\n        }\n      }\n\n      const equal = node.textContent.match(PLACEHOLDER_REGEXP_EQUAL);\n      if (equal) {\n        node.textContent = \"\";\n        parts[equal[1]] = [compileIndex, resolveValue];\n      }\n    } else {\n      /* istanbul ignore else */ // eslint-disable-next-line no-lonely-if\n      if (node.nodeType === global.Node.ELEMENT_NODE) {\n        /* istanbul ignore else */ // eslint-disable-next-line no-lonely-if\n        if (probablyDevMode) {\n          const tagName = node.tagName.toLowerCase();\n          if (\n            tagName.match(/.+-.+/) &&\n            !global.customElements.get(tagName) &&\n            !notDefinedElements.includes(tagName)\n          ) {\n            notDefinedElements.push(tagName);\n          }\n        }\n\n        Array.from(node.attributes).forEach((attr) => {\n          const value = attr.value.trim();\n          /* istanbul ignore next */\n          const name = attr.name;\n          const equal = value.match(PLACEHOLDER_REGEXP_EQUAL);\n          if (equal) {\n            const propertyName = getPropertyName(rawParts[equal[1]]);\n            parts[equal[1]] = [\n              compileIndex,\n              resolveProperty(name, propertyName, isSVG),\n            ];\n            node.removeAttribute(attr.name);\n          } else {\n            const results = value.match(PLACEHOLDER_REGEXP_ALL);\n            if (results) {\n              const partialName = `attr__${name}`;\n\n              results.forEach((placeholder, index) => {\n                const [, id] = placeholder.match(PLACEHOLDER_REGEXP_EQUAL);\n                let isProp = false;\n                parts[id] = [\n                  compileIndex,\n                  (host, target, attrValue) => {\n                    const data = dataMap.get(target, {});\n                    data[partialName] = (data[partialName] || value).replace(\n                      placeholder,\n                      attrValue == null ? \"\" : attrValue,\n                    );\n\n                    if (results.length === 1 || index + 1 === results.length) {\n                      isProp =\n                        isProp ||\n                        (!isSVG &&\n                          !(target instanceof global.SVGElement) &&\n                          name in target);\n                      if (isProp) {\n                        target[name] = data[partialName];\n                      } else {\n                        target.setAttribute(name, data[partialName]);\n                      }\n                      data[partialName] = undefined;\n                    }\n                  },\n                ];\n              });\n\n              attr.value = \"\";\n            }\n          }\n        });\n      }\n    }\n\n    compileIndex += 1;\n  }\n\n  if (probablyDevMode && notDefinedElements.length) {\n    console.warn(\n      `Not defined ${notDefinedElements\n        .map((e) => `<${e}>`)\n        .join(\", \")} element${\n        notDefinedElements.length > 1 ? \"s\" : \"\"\n      } found in the template:\\n${beautifyTemplateLog(signature, -1)}`,\n    );\n  }\n\n  return function updateTemplateInstance(host, target, args, styleSheets) {\n    const data = dataMap.get(target, { type: \"function\" });\n\n    if (template !== data.template) {\n      if (data.template || target.nodeType !== global.Node.TEXT_NODE) {\n        removeTemplate(target);\n      }\n\n      data.prevArgs = null;\n\n      const fragment = global.document.importNode(\n        applyShadyCSS(template, host.tagName).content,\n        true,\n      );\n\n      const renderWalker = createWalker(fragment);\n      const clonedParts = parts.slice(0);\n\n      let renderIndex = 0;\n      let currentPart = clonedParts.shift();\n\n      const markers = [];\n\n      data.template = template;\n      data.markers = markers;\n\n      while (renderWalker.nextNode()) {\n        const node = renderWalker.currentNode;\n\n        while (currentPart && currentPart[0] === renderIndex) {\n          markers.push([node, currentPart[1]]);\n          currentPart = clonedParts.shift();\n        }\n\n        renderIndex += 1;\n      }\n\n      if (target.nodeType === global.Node.TEXT_NODE) {\n        data.startNode = fragment.childNodes[0];\n        data.endNode = fragment.childNodes[fragment.childNodes.length - 1];\n\n        let previousChild = target;\n\n        let child = fragment.childNodes[0];\n        while (child) {\n          target.parentNode.insertBefore(child, previousChild.nextSibling);\n          previousChild = child;\n          child = fragment.childNodes[0];\n        }\n      } else {\n        target.appendChild(fragment);\n      }\n    }\n\n    const adoptedStyleSheets = target.adoptedStyleSheets;\n    if (styleSheets) {\n      let isEqual = false;\n\n      styleSheets = styleSheets.map((style) => {\n        if (style instanceof global.CSSStyleSheet) return style;\n\n        let styleSheet = styleSheetsMap.get(style);\n        if (!styleSheet) {\n          styleSheet = new global.CSSStyleSheet();\n          styleSheet.replaceSync(style);\n          styleSheetsMap.set(style, styleSheet);\n        }\n        return styleSheet;\n      });\n\n      if (styleSheets.length === adoptedStyleSheets.length) {\n        isEqual = true;\n        for (let i = 0; i < styleSheets.length; i += 1) {\n          if (styleSheets[i] !== adoptedStyleSheets[i]) {\n            isEqual = false;\n            break;\n          }\n        }\n      }\n\n      if (!isEqual) target.adoptedStyleSheets = styleSheets;\n    } else if (adoptedStyleSheets && adoptedStyleSheets.length) {\n      target.adoptedStyleSheets = [];\n    }\n\n    const prevArgs = data.prevArgs;\n    data.prevArgs = args;\n\n    for (let index = 0; index < data.markers.length; index += 1) {\n      if (prevArgs && prevArgs[index] === args[index]) continue; // eslint-disable-line no-continue\n      const [node, marker] = data.markers[index];\n\n      try {\n        marker(host, node, args[index], prevArgs && prevArgs[index]);\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error(\n          `Following error was thrown when updating a template expression in ${stringifyElement(\n            host,\n          )}\\n${beautifyTemplateLog(signature, index)}`,\n        );\n        throw error;\n      }\n    }\n\n    if (target.nodeType !== global.Node.TEXT_NODE) {\n      shadyCSS((shady) => {\n        if (host.shadowRoot) {\n          if (prevArgs) {\n            shady.styleSubtree(host);\n          } else {\n            shady.styleElement(host);\n          }\n        }\n      });\n    }\n  };\n};exports.compileTemplate = compileTemplate\n","var __TEMP__ = require('../global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst map = new WeakMap();\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var dataMap = exports.dataMap = {\n  get(key, defaultValue) {\n    const value = map.get(key);\n    if (value) return value;\n\n    if (defaultValue) {\n      map.set(key, defaultValue);\n    }\n\n    return defaultValue;\n  },\n  set(key, value) {\n    map.set(key, value);\n    return value;\n  },\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getTemplateEnd(node) {\n  let data;\n  // eslint-disable-next-line no-cond-assign\n  while (node && (data = dataMap.get(node)) && data.endNode) {\n    node = data.endNode;\n  }\n\n  return node;\n};exports.getTemplateEnd = getTemplateEnd\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function removeTemplate(target) {\n  if (target.nodeType !== global.Node.TEXT_NODE) {\n    let child = target.childNodes[0];\n    while (child) {\n      target.removeChild(child);\n      child = target.childNodes[0];\n    }\n  } else {\n    const data = dataMap.get(target);\n\n    if (data.startNode) {\n      const endNode = getTemplateEnd(data.endNode);\n\n      let node = data.startNode;\n      const lastNextSibling = endNode.nextSibling;\n\n      while (node) {\n        const nextSibling = node.nextSibling;\n        node.parentNode.removeChild(node);\n        node = nextSibling !== lastNextSibling && nextSibling;\n      }\n    }\n  }\n};exports.removeTemplate = removeTemplate\n","var __TEMP__ = require('../../global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../utils.js');var dataMap = __TEMP__['dataMap'];var removeTemplate = __TEMP__['removeTemplate'];\nvar __TEMP__ = require('./array.js');var resolveArray = __REQUIRE_DEFAULT__(__TEMP__);var arrayMap = __TEMP__['arrayMap'];\nvar __TEMP__ = require('./node.js');var resolveNode = __REQUIRE_DEFAULT__(__TEMP__);\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function resolveValue(host, target, value, lastValue) {\n  let type = typeof value;\n  if (Array.isArray(value)) {\n    type = \"array\";\n  } else if (value instanceof global.Node) {\n    type = \"node\";\n  }\n\n  let data = dataMap.get(target, {});\n\n  if (data.type !== type) {\n    removeTemplate(target);\n    if (type === \"array\") arrayMap.delete(target);\n\n    data = dataMap.set(target, { type });\n\n    if (target.textContent !== \"\") {\n      target.textContent = \"\";\n    }\n  }\n\n  switch (type) {\n    case \"function\":\n      value(host, target);\n      break;\n    case \"array\":\n      resolveArray(host, target, value, resolveValue);\n      break;\n    case \"node\":\n      resolveNode(host, target, value, lastValue);\n      break;\n    default:\n      target.textContent = type === \"number\" || value ? value : \"\";\n  }\n};exports.default = resolveValue\n","var __TEMP__ = require('../../global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../utils.js');var dataMap = __TEMP__['dataMap'];var removeTemplate = __TEMP__['removeTemplate'];var getTemplateEnd = __TEMP__['getTemplateEnd'];\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var arrayMap = exports.arrayMap = new WeakMap();\n\nfunction movePlaceholder(target, previousSibling) {\n  const data = dataMap.get(target);\n  const startNode = data.startNode;\n  const endNode = getTemplateEnd(data.endNode);\n\n  previousSibling.parentNode.insertBefore(target, previousSibling.nextSibling);\n\n  let prevNode = target;\n  let node = startNode;\n  while (node) {\n    const nextNode = node.nextSibling;\n    prevNode.parentNode.insertBefore(node, prevNode.nextSibling);\n    prevNode = node;\n    node = nextNode !== endNode.nextSibling && nextNode;\n  }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function resolveArray(host, target, value, resolveValue) {\n  let lastEntries = arrayMap.get(target);\n  const entries = value.map((item, index) => ({\n    id: hasOwnProperty.call(item, \"id\") ? item.id : index,\n    value: item,\n    placeholder: null,\n    available: true,\n  }));\n\n  arrayMap.set(target, entries);\n\n  if (lastEntries) {\n    const ids = new Set();\n    entries.forEach((entry) => ids.add(entry.id));\n\n    lastEntries = lastEntries.filter((entry) => {\n      if (!ids.has(entry.id)) {\n        removeTemplate(entry.placeholder);\n        entry.placeholder.parentNode.removeChild(entry.placeholder);\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  let previousSibling = target;\n  const lastIndex = value.length - 1;\n  const data = dataMap.get(target);\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    let matchedEntry;\n    if (lastEntries) {\n      for (let i = 0; i < lastEntries.length; i += 1) {\n        if (lastEntries[i].available && lastEntries[i].id === entry.id) {\n          matchedEntry = lastEntries[i];\n          break;\n        }\n      }\n    }\n\n    if (matchedEntry) {\n      matchedEntry.available = false;\n      entry.placeholder = matchedEntry.placeholder;\n\n      if (entry.placeholder.previousSibling !== previousSibling) {\n        movePlaceholder(entry.placeholder, previousSibling);\n      }\n      if (matchedEntry.value !== entry.value) {\n        resolveValue(host, entry.placeholder, entry.value, matchedEntry.value);\n      }\n    } else {\n      entry.placeholder = global.document.createTextNode(\"\");\n      previousSibling.parentNode.insertBefore(\n        entry.placeholder,\n        previousSibling.nextSibling,\n      );\n      resolveValue(host, entry.placeholder, entry.value);\n    }\n\n    previousSibling = getTemplateEnd(\n      dataMap.get(entry.placeholder).endNode || entry.placeholder,\n    );\n\n    if (index === 0) data.startNode = entry.placeholder;\n    if (index === lastIndex) data.endNode = previousSibling;\n  }\n\n  if (lastEntries) {\n    lastEntries.forEach((entry) => {\n      if (entry.available) {\n        removeTemplate(entry.placeholder);\n        entry.placeholder.parentNode.removeChild(entry.placeholder);\n      }\n    });\n  }\n};exports.default = resolveArray\n","var __TEMP__ = require('../utils.js');var dataMap = __TEMP__['dataMap'];\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function resolveNode(host, target, value, lastValue) {\n  const data = dataMap.get(target, {});\n\n  if (lastValue) lastValue.parentNode.removeChild(lastValue);\n\n  data.startNode = value;\n  data.endNode = value;\n\n  target.parentNode.insertBefore(value, target.nextSibling);\n};exports.default = resolveNode\n","var __TEMP__ = require('../../global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./event.js');var resolveEventListener = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./class.js');var resolveClassList = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./style.js');var resolveStyleList = __REQUIRE_DEFAULT__(__TEMP__);\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function resolveProperty(attrName, propertyName, isSVG) {\n  if (propertyName.substr(0, 2) === \"on\") {\n    const eventType = propertyName.substr(2);\n    return resolveEventListener(eventType);\n  }\n\n  switch (attrName) {\n    case \"class\":\n      return resolveClassList;\n    case \"style\":\n      return resolveStyleList;\n    default: {\n      let isProp = false;\n      return (host, target, value) => {\n        isProp =\n          isProp ||\n          (!isSVG &&\n            !(target instanceof global.SVGElement) &&\n            propertyName in target);\n        if (isProp) {\n          target[propertyName] = value;\n        } else if (value === false || value === undefined || value === null) {\n          target.removeAttribute(attrName);\n        } else {\n          const attrValue = value === true ? \"\" : String(value);\n          target.setAttribute(attrName, attrValue);\n        }\n      };\n    }\n  }\n};exports.default = resolveProperty\n","const targets = new WeakMap();\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function resolveEventListener(eventType) {\n  return (host, target, value, lastValue) => {\n    if (lastValue) {\n      const eventMap = targets.get(target);\n      if (eventMap) {\n        target.removeEventListener(\n          eventType,\n          eventMap.get(lastValue),\n          lastValue.options !== undefined ? lastValue.options : false,\n        );\n      }\n    }\n\n    if (value) {\n      if (typeof value !== \"function\") {\n        throw Error(`Event listener must be a function: ${typeof value}`);\n      }\n\n      let eventMap = targets.get(target);\n      if (!eventMap) {\n        eventMap = new WeakMap();\n        targets.set(target, eventMap);\n      }\n\n      const callback = value.bind(null, host);\n      eventMap.set(value, callback);\n\n      target.addEventListener(\n        eventType,\n        callback,\n        value.options !== undefined ? value.options : false,\n      );\n    }\n  };\n};exports.default = resolveEventListener\n","function normalizeValue(value, set = new Set()) {\n  if (Array.isArray(value)) {\n    value.forEach((className) => set.add(className));\n  } else if (value !== null && typeof value === \"object\") {\n    Object.keys(value).forEach((key) => value[key] && set.add(key));\n  } else {\n    set.add(value);\n  }\n\n  return set;\n}\n\nconst classMap = new WeakMap();\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function resolveClassList(host, target, value) {\n  const previousList = classMap.get(target) || new Set();\n  const list = normalizeValue(value);\n\n  classMap.set(target, list);\n\n  list.forEach((className) => {\n    target.classList.add(className);\n    previousList.delete(className);\n  });\n\n  previousList.forEach((className) => {\n    target.classList.remove(className);\n  });\n};exports.default = resolveClassList\n","var __TEMP__ = require('../../utils.js');var camelToDash = __TEMP__['camelToDash'];var stringifyElement = __TEMP__['stringifyElement'];\n\nconst styleMap = new WeakMap();\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function resolveStyle(host, target, value) {\n  if (value === null || typeof value !== \"object\") {\n    throw TypeError(\n      `Style value must be an object in ${stringifyElement(target)}:`,\n      value,\n    );\n  }\n\n  const previousMap = styleMap.get(target) || new Map();\n\n  const nextMap = Object.keys(value).reduce((map, key) => {\n    const dashKey = camelToDash(key);\n    const styleValue = value[key];\n\n    if (!styleValue && styleValue !== 0) {\n      target.style.removeProperty(dashKey);\n    } else {\n      target.style.setProperty(dashKey, styleValue);\n    }\n\n    map.set(dashKey, styleValue);\n    previousMap.delete(dashKey);\n\n    return map;\n  }, new Map());\n\n  previousMap.forEach((styleValue, key) => {\n    target.style[key] = \"\";\n  });\n\n  styleMap.set(target, nextMap);\n};exports.default = resolveStyle\n","var __TEMP__ = require('../global.js');var global = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../utils.js');var storePointer = __TEMP__['storePointer'];\nvar __TEMP__ = require('./resolvers/value.js');var resolveTemplateValue = __REQUIRE_DEFAULT__(__TEMP__);\n\nfunction resolveValue({ target, detail }, setter) {\n  let value;\n\n  switch (target.type) {\n    case \"radio\":\n    case \"checkbox\":\n      value = target.checked && target.value;\n      break;\n    case \"file\":\n      value = target.files;\n      break;\n    default:\n      value =\n        detail && hasOwnProperty.call(detail, \"value\")\n          ? detail.value\n          : target.value;\n  }\n\n  setter(value);\n}\n\nfunction getPartialObject(name, value) {\n  return name\n    .split(\".\")\n    .reverse()\n    .reduce((acc, key) => {\n      if (!acc) return { [key]: value };\n      return { [key]: acc };\n    }, null);\n}\n\nconst stringCache = new Map();\nconst storeValues = new WeakMap();\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function set(property, valueOrPath) {\n  if (!property) {\n    throw Error(\n      `The first argument must be a property name or an object instance: ${property}`,\n    );\n  }\n\n  if (typeof property === \"object\") {\n    if (valueOrPath === undefined) {\n      throw Error(\n        \"For model instance property the second argument must be defined\",\n      );\n    }\n\n    const store = storePointer.get(property);\n\n    if (!store) {\n      throw Error(\"Provided object must be a model instance of the store\");\n    }\n\n    if (valueOrPath === null) {\n      return () => {\n        store.set(property, null);\n      };\n    }\n\n    return (host, event) => {\n      resolveValue(event, (value) => {\n        const values = storeValues.get(property);\n\n        if (!values) {\n          global.requestAnimationFrame(() => {\n            const result = storeValues.get(property);\n            storeValues.delete(property);\n\n            store\n              .set(property, result)\n              .catch(/* istanbul ignore next */ () => {});\n          });\n        }\n\n        storeValues.set(property, {\n          ...values,\n          ...getPartialObject(valueOrPath, value),\n        });\n      });\n    };\n  }\n\n  if (arguments.length === 2) {\n    return (host) => {\n      host[property] = valueOrPath;\n    };\n  }\n\n  let fn = stringCache.get(property);\n\n  if (!fn) {\n    fn = (host, event) => {\n      resolveValue(event, (value) => {\n        host[property] = value;\n      });\n    };\n\n    stringCache.set(property, fn);\n  }\n\n  return fn;\n};exports.set = set\n\nconst promiseMap = new WeakMap();\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function resolve(promise, placeholder, delay = 200) {\n  return (host, target) => {\n    let timeout;\n\n    if (placeholder) {\n      timeout = setTimeout(() => {\n        timeout = undefined;\n\n        global.requestAnimationFrame(() => {\n          placeholder(host, target);\n        });\n      }, delay);\n    }\n\n    promiseMap.set(target, promise);\n\n    promise.then((value) => {\n      if (timeout) clearTimeout(timeout);\n\n      if (promiseMap.get(target) === promise) {\n        resolveTemplateValue(host, target, value);\n        promiseMap.set(target, null);\n      }\n    });\n  };\n};exports.resolve = resolve\n"]}